<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Island Builder - Multiplayer</title>
    <style>
        /* Existing styles... */

        /* NEW: Timer Display */
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        /* NEW: Spectator Indicator */
        #spectator-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5555;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,85,85,0.7);
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 15px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }

        /* NEW: Waiting Message */
        #waiting-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff88;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,136,0.7);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 15px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }

        /* Move stats down for timer */
        #stats {
            position: absolute;
            top: 80px; /* Moved down for timer */
            left: 20px;
            /* rest unchanged */
        }
    </style>
</head>
<body>
    <!-- NEW: Timer Display -->
    <div id="timer">15:00</div>
    
    <!-- NEW: Spectator Indicator -->
    <div id="spectator-indicator">SPECTATOR MODE</div>
    
    <!-- NEW: Waiting Message -->
    <div id="waiting-message"></div>
    
    <!-- Existing elements... -->
    <div id="loading">Connecting to server...</div>
    <div id="crosshair"></div>
    <!-- ... rest of body ... -->

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const socket = io({ reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000 });

        // Hide loading when connected
        socket.on('connect', () => {
            document.getElementById('loading').style.display = 'none';
        });

        // --- NEW: Game State ---
        let isSpectator = false;
        let roundTimeRemaining = 900; // 15 minutes in seconds
        let roundTimerInterval = null;
        let isInRound = false;

        // --- Updated Config ---
        const BLOCK_TYPES = {
            'Grass': { color: 0x4d9043, cost: { iron: 5 }, breakTime: 1.2, buyAmount: 8, hasTexture: true },
            'Glass': { color: 0xade8f4, cost: { iron: 5 }, breakTime: 0.4, buyAmount: 16, opacity: 0.6 },
            'Wood': { color: 0x5d4037, cost: { gold: 5 }, breakTime: 3, buyAmount: 32, hasTexture: true },
            'Stone': { color: 0x777777, cost: { gold: 5 }, breakTime: 6, buyAmount: 8, hasTexture: true },
            'Obsidian': { color: 0x111111, cost: { emerald: 1 }, breakTime: 12, buyAmount: 1, hasTexture: true },
            'Bed': { color: 0xff0000, breakTime: 2, buyAmount: 1, hasTexture: false }
        };
        const MAX_STACK = 64;
        const INVENTORY_SIZE = 9;
        const ISLAND_GAP = 18;

        // --- State ---
        let currency = { iron: 0, gold: 0, emerald: 0 };
        let inventory = new Array(INVENTORY_SIZE).fill(null);
        let selectedSlotIndex = 0;
        let overlayTimeout;

        const blocksInScene = [];
        const resourceSpawners = [];
        const resourcePickups = [];

        // Breaking state
        let isBreaking = false;
        let breakingBlock = null;
        let breakingStartTime = 0;
        let breakingDuration = 0;
        let breakingOverlay = null;

        // Crouching state
        let isCrouching = false;

        let playerId = null;
        let blocksMeshes = new Map();
        let pickupMeshes = new Map();
        let otherPlayers = new Map();

        // --- NEW: Timer Functions ---
        function updateTimerDisplay(seconds) {
            const timerElement = document.getElementById('timer');
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            timerElement.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function startRoundTimer(initialTime) {
            roundTimeRemaining = initialTime;
            updateTimerDisplay(roundTimeRemaining);
            document.getElementById('timer').style.display = 'block';
            
            if (roundTimerInterval) clearInterval(roundTimerInterval);
            
            roundTimerInterval = setInterval(() => {
                if (isInRound && roundTimeRemaining > 0) {
                    roundTimeRemaining--;
                    updateTimerDisplay(roundTimeRemaining);
                    
                    if (roundTimeRemaining <= 0) {
                        clearInterval(roundTimerInterval);
                        document.getElementById('timer').style.display = 'none';
                    }
                }
            }, 1000);
        }

        function stopRoundTimer() {
            if (roundTimerInterval) {
                clearInterval(roundTimerInterval);
                roundTimerInterval = null;
            }
            document.getElementById('timer').style.display = 'none';
        }

        // --- NEW: Spectator Functions ---
        function setSpectatorMode(spectator) {
            isSpectator = spectator;
            const indicator = document.getElementById('spectator-indicator');
            
            if (spectator) {
                indicator.style.display = 'block';
                // Hide UI elements for spectators
                document.getElementById('stats').style.display = 'none';
                document.getElementById('hotbar-container').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('controls-hint').style.display = 'none';
                
                // Make player invisible to others (handled by server)
                // Enable flying/spectator controls
                velocity.y = 0; // Reset velocity
                onGround = true; // Prevent falling
            } else {
                indicator.style.display = 'none';
                // Show UI elements
                document.getElementById('stats').style.display = 'block';
                document.getElementById('hotbar-container').style.display = 'flex';
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('controls-hint').style.display = 'block';
            }
        }

        // --- NEW: Waiting Message Function ---
        function updateWaitingMessage(playersNeeded) {
            const messageElement = document.getElementById('waiting-message');
            if (playersNeeded > 0) {
                messageElement.textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''}...`;
                messageElement.style.display = 'block';
            } else {
                messageElement.style.display = 'none';
            }
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6eb1ff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(20, 50, 20);
        scene.add(sun);

        // Load textures (unchanged)...

        // --- World Generation (unchanged)...

        // --- Physics & Controls ---
        const PLAYER_HEIGHT = 1.8;
        const EYE_HEIGHT = 1.6;
        const CROUCH_HEIGHT = 1.3;
        const PLAYER_RADIUS = 0.4;

        camera.position.set(-12, 5, -12);
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const moveState = { fwd: false, bwd: false, l: false, r: false };
        let onGround = false;

        // Event listeners with spectator checks
        document.addEventListener('keydown', (e) => {
            if (isSpectator) {
                // Spectator controls - allow flying
                if(e.code === 'KeyB') return; // No shop for spectators
                
                // Flying controls
                switch(e.code) {
                    case 'KeyW': moveState.fwd = true; break;
                    case 'KeyS': moveState.bwd = true; break;
                    case 'KeyA': moveState.l = true; break;
                    case 'KeyD': moveState.r = true; break;
                    case 'Space': velocity.y = 5; break; // Fly up
                    case 'ShiftLeft':
                    case 'ShiftRight': velocity.y = -5; break; // Fly down
                }
                return;
            }

            if(e.code === 'KeyB') toggleShop();
            if(document.getElementById('shop').style.display === 'block') return;

            if (e.code.startsWith('Digit') && e.code !== 'Digit0') {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 9) {
                    selectSlot(num - 1);
                }
            }

            switch(e.code) {
                case 'KeyW': moveState.fwd = true; break;
                case 'KeyS': moveState.bwd = true; break;
                case 'KeyA': moveState.l = true; break;
                case 'KeyD': moveState.r = true; break;
                case 'Space':
                    if(onGround && !isCrouching) {
                        velocity.y = 7.5;
                        onGround = false;
                    } else if (onGround && isCrouching) {
                        velocity.y = 6;
                        onGround = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    e.preventDefault();
                    if (!isCrouching) {
                        isCrouching = true;
                        document.getElementById('crouch-hint').classList.add('crouch-indicator');
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (isSpectator) {
                switch(e.code) {
                    case 'KeyW': moveState.fwd = false; break;
                    case 'KeyS': moveState.bwd = false; break;
                    case 'KeyA': moveState.l = false; break;
                    case 'KeyD': moveState.r = false; break;
                    case 'Space':
                    case 'ShiftLeft':
                    case 'ShiftRight': velocity.y = 0; break; // Stop vertical movement
                }
                return;
            }

            switch(e.code) {
                case 'KeyW': moveState.fwd = false; break;
                case 'KeyS': moveState.bwd = false; break;
                case 'KeyA': moveState.l = false; break;
                case 'KeyD': moveState.r = false; break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isCrouching = false;
                    document.getElementById('crouch-hint').classList.remove('crouch-indicator');
                    break;
            }
        });

        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousedown', (e) => {
            // Spectators can't interact
            if (isSpectator) return;
            
            if (!controls.isLocked) {
                if(document.getElementById('shop').style.display !== 'block') controls.lock();
                return;
            }

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(blocksInScene);

            if (e.button === 2) { // Build
                const currentSlot = inventory[selectedSlotIndex];
                if (intersects.length > 0 && currentSlot && currentSlot.count > 0) {
                    const intersect = intersects[0];
                    if (intersect.distance > 5) return;
                    const pos = intersect.point.clone().add(intersect.face.normal.multiplyScalar(0.5));

                    const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                    const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;

                    const blockX = Math.floor(pos.x);
                    const blockY = Math.floor(pos.y);
                    const blockZ = Math.floor(pos.z);

                    let canPlace = true;
                    const playerFeetY = camera.position.y - currentEyeHeight;
                    const playerHeadY = camera.position.y - currentEyeHeight + currentPlayerHeight;
                    const blockMinY = blockY;
                    const blockMaxY = blockY + 1;
                    if (blockMaxY > playerFeetY && blockMinY < playerHeadY) {
                        const dx = Math.abs(camera.position.x - (blockX + 0.5));
                        const dz = Math.abs(camera.position.z - (blockZ + 0.5));
                        if (dx < PLAYER_RADIUS * 0.6 && dz < PLAYER_RADIUS * 0.6) {
                            canPlace = false;
                        }
                    }

                    if (canPlace) {
                        const type = currentSlot.type;
                        socket.emit('placeAttempt', { x: blockX, y: blockY, z: blockZ, type });
                    }
                }
            } else if (e.button === 0) { // Break
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (intersects[0].distance > 5) return;
                    if (obj.userData.type !== 'spawner') {
                        const type = obj.userData.type || 'Grass';
                        isBreaking = true;
                        breakingBlock = obj;
                        breakingStartTime = Date.now();
                        breakingDuration = BLOCK_TYPES[type].breakTime * 1000;
                        document.getElementById('break-progress').style.display = 'block';
                        
                        if (!breakingOverlay && breakingTextures.length > 0) {
                            const overlayMaterial = new THREE.MeshBasicMaterial({
                                map: breakingTextures[0],
                                transparent: true,
                                opacity: 0.8,
                                depthWrite: false
                            });
                            breakingOverlay = new THREE.Mesh(
                                new THREE.BoxGeometry(1.01, 1.01, 1.01),
                                overlayMaterial
                            );
                            breakingOverlay.position.copy(obj.position);
                            scene.add(breakingOverlay);
                        }
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isBreaking = false;
                breakingBlock = null;
                document.getElementById('break-progress').style.display = 'none';
                document.getElementById('break-progress-bar').style.width = '0%';
                if (breakingOverlay) {
                    scene.remove(breakingOverlay);
                    breakingOverlay = null;
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Collision functions
        function checkCollision(pos) {
            if (isSpectator) return false; // Spectators don't collide
            
            const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
            const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(pos.x, pos.y - (currentEyeHeight - currentPlayerHeight/2), pos.z),
                new THREE.Vector3(PLAYER_RADIUS * 2, currentPlayerHeight - 0.1, PLAYER_RADIUS * 2)
            );
            for (const b of blocksInScene) {
                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(b))) return true;
            }
            return false;
        }

        function wouldFallOffEdge(pos, direction) {
            if (isSpectator) return false; // Spectators can't fall
            if (!isCrouching || !onGround) return false;
            
            const checkDistance = -0.11;
            const checkPos = pos.clone().add(direction.multiplyScalar(checkDistance));
            checkPos.y -= EYE_HEIGHT + 0.2;
            const checkBox = new THREE.Box3().setFromCenterAndSize(
                checkPos,
                new THREE.Vector3(0.1, 0.1, 0.1)
            );
            for (const b of blocksInScene) {
                if (checkBox.intersectsBox(new THREE.Box3().setFromObject(b))) return false;
            }
            return true;
        }

        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);
            prevTime = time;

            // Breaking logic
            if (isBreaking && breakingBlock && !isSpectator) {
                const elapsed = Date.now() - breakingStartTime;
                const progress = Math.min((elapsed / breakingDuration) * 100, 100);
                document.getElementById('break-progress-bar').style.width = progress + '%';

                if (breakingOverlay && breakingTextures.length > 0) {
                    const textureIndex = Math.floor(progress / 10) - 1;
                    if (textureIndex >= 0 && textureIndex < breakingTextures.length) {
                        breakingOverlay.material.map = breakingTextures[textureIndex];
                        breakingOverlay.material.needsUpdate = true;
                    }
                }

                if (elapsed >= breakingDuration) {
                    const x = Math.floor(breakingBlock.position.x - 0.5);
                    const y = Math.floor(breakingBlock.position.y - 0.5);
                    const z = Math.floor(breakingBlock.position.z - 0.5);
                    socket.emit('breakAttempt', { x, y, z });
                    isBreaking = false;
                    breakingBlock = null;
                    document.getElementById('break-progress').style.display = 'none';
                    document.getElementById('break-progress-bar').style.width = '0%';
                    if (breakingOverlay) {
                        scene.remove(breakingOverlay);
                        breakingOverlay = null;
                    }
                }
            }

            const now = Date.now();

            // Spawners animation
            resourceSpawners.forEach(spawner => {
                const pulseSpeed = 2;
                const pulseAmount = 0.1;
                const scale = 1 + Math.sin(now / 200 * pulseSpeed) * pulseAmount;
                spawner.scale.set(scale, scale, scale);
            });

            // Resource pickups animation
            for (let i = resourcePickups.length - 1; i >= 0; i--) {
                const pickup = resourcePickups[i];
                
                // Floating
                const floatOffset = Math.sin((now - pickup.userData.spawnTime) / 500) * 0.15;
                pickup.position.y = pickup.userData.baseY + floatOffset;
                
                // Billboard: always face the camera on the front face
                pickup.lookAt(camera.position);

                // Collection
                const dist = camera.position.distanceTo(pickup.position);
                if (dist < 1.5 && !isSpectator) {
                    socket.emit('claimPickupAttempt', pickup.userData.id);
                    removePickupMesh(pickup.userData.id);
                }
            }

            // Movement and physics
            if (controls.isLocked) {
                if (isSpectator) {
                    // Spectator flying movement
                    const direction = new THREE.Vector3();
                    direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                    direction.x = Number(moveState.r) - Number(moveState.l);
                    direction.normalize();
                    
                    const speed = 10.0;
                    const flySpeed = 5.0;
                    
                    if (direction.x !== 0) {
                        const moveDir = new THREE.Vector3(1, 0, 0);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.normalize();
                        controls.moveRight(direction.x * speed * delta);
                    }

                    if (direction.z !== 0) {
                        const moveDir = new THREE.Vector3(0, 0, -1);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.normalize();
                        controls.moveForward(direction.z * speed * delta);
                    }
                    
                    // Vertical movement
                    camera.position.y += velocity.y * delta;
                    
                    // No gravity for spectators
                    velocity.y = 0;
                    onGround = true;
                } else {
                    // Normal player movement
                    velocity.y -= 20.0 * delta;

                    const direction = new THREE.Vector3();
                    direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                    direction.x = Number(moveState.r) - Number(moveState.l);
                    direction.normalize();

                    const baseSpeed = 5.0;
                    const speed = isCrouching ? baseSpeed * 0.6 : baseSpeed;

                    if (direction.x !== 0) {
                        const moveDir = new THREE.Vector3(1, 0, 0);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.x))) {
                            controls.moveRight(direction.x * speed * delta);
                            if (checkCollision(camera.position)) controls.moveRight(-direction.x * speed * delta);
                        }
                    }

                    if (direction.z !== 0) {
                        const moveDir = new THREE.Vector3(0, 0, -1);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.z))) {
                            controls.moveForward(direction.z * speed * delta);
                            if (checkCollision(camera.position)) controls.moveForward(-direction.z * speed * delta);
                        }
                    }

                    camera.position.y += velocity.y * delta;
                    onGround = false;

                    const currentEyeHeightForFoot = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                    const footBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(camera.position.x, camera.position.y - currentEyeHeightForFoot, camera.position.z),
                        new THREE.Vector3(PLAYER_RADIUS, 0.2, PLAYER_RADIUS)
                    );

                    for (const b of blocksInScene) {
                        const bBox = new THREE.Box3().setFromObject(b);
                        if (footBox.intersectsBox(bBox)) {
                            if (velocity.y < 0) {
                                velocity.y = 0;
                                camera.position.y = bBox.max.y + currentEyeHeightForFoot;
                                onGround = true;
                            }
                        }
                    }

                    // Death handled server-side
                    if (camera.position.y < -30 && isInRound) {
                        // Player fell - server will handle respawn or spectator mode
                    }
                }
            }

            // Player update send
            if (controls.isLocked && socket.connected && time - lastPlayerUpdate > PLAYER_UPDATE_RATE) {
                socket.emit('playerUpdate', {
                    pos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    rot: { yaw: camera.rotation.y, pitch: camera.rotation.x },
                    crouch: isCrouching,
                    selected: selectedSlotIndex,
                    spectator: isSpectator // Send spectator status
                });
                lastPlayerUpdate = time;
            }

            // Other players lerp
            otherPlayers.forEach((data) => {
                // Don't render spectators
                if (data.spectator) {
                    data.group.visible = false;
                    return;
                }
                
                data.group.visible = true;
                data.group.position.lerp(new THREE.Vector3(data.targetPos.x, data.targetPos.y, data.targetPos.z), 0.15);
                data.group.rotation.y = THREE.MathUtils.lerp(data.group.rotation.y || 0, data.targetRot.yaw, 0.15);
                data.head.rotation.x = THREE.MathUtils.lerp(data.head.rotation.x || 0, data.targetRot.pitch, 0.15);
                
                // Crouch
                if (data.targetCrouch !== data.crouch) {
                    data.crouch = data.targetCrouch;
                }
                data.group.scale.y = data.crouch ? 0.75 : 1;
            });

            renderer.render(scene, camera);
        }

        let lastPlayerUpdate = 0;
        const PLAYER_UPDATE_RATE = 50;

        // Inventory, UI, shop functions (unchanged)...

        // Socket events
        socket.on('yourId', (id) => {
            playerId = id;
        });

        socket.on('initWorld', ({ blocks, pickups, spawners: initSpawners, gameState: serverGameState, playersNeeded }) => {
            blocks.forEach(({ x, y, z, type }) => addBlockMesh(x, y, z, type));
            pickups.forEach(addPickupMesh);
            initSpawners.forEach(s => addResourceSpawner(s.x, s.y, s.z, s.resourceType, s.interval / 1000));
            
            // Update waiting message
            if (serverGameState === 'waiting') {
                updateWaitingMessage(playersNeeded);
            }
        });

        socket.on('playersSnapshot', (others) => {
            others.forEach(({ id, pos, rot, crouch, spectator }) => {
                if (spectator) return; // Don't create spectator players
                createOtherPlayer(id);
                const op = otherPlayers.get(id);
                op.targetPos = pos;
                op.targetRot = rot;
                op.targetCrouch = crouch;
            });
        });

        socket.on('newPlayer', ({ id, pos, rot, crouch, spectator }) => {
            if (spectator) return; // Don't create spectator players
            createOtherPlayer(id);
            const op = otherPlayers.get(id);
            op.targetPos = pos;
            op.targetRot = rot;
            op.targetCrouch = crouch;
        });

        socket.on('playersUpdate', (states) => {
            states.forEach(({ id, pos, rot, crouch, spectator }) => {
                if (id === playerId) return;
                const op = otherPlayers.get(id);
                if (op) {
                    op.targetPos = pos;
                    op.targetRot = rot;
                    op.targetCrouch = crouch;
                    op.spectator = spectator;
                }
            });
        });

        socket.on('addBlock', ({ x, y, z, type }) => addBlockMesh(x, y, z, type));
        socket.on('removeBlock', ({ x, y, z }) => removeBlockMesh(x, y, z));
        socket.on('addPickup', addPickupMesh);
        socket.on('removePickup', (id) => removePickupMesh(id));

        socket.on('revertBreak', ({ x, y, z, type }) => {
            if (type) addBlockMesh(x, y, z, type);
            else removeBlockMesh(x, y, z);
        });
        socket.on('revertPlace', ({ x, y, z }) => removeBlockMesh(x, y, z));
        socket.on('revertPickup', addPickupMesh);

        socket.on('updateCurrency', (curr) => {
            currency = curr;
            updateUI();
        });
        socket.on('updateInventory', (inv) => {
            inventory = inv;
            updateUI();
        });
        socket.on('buyFailed', () => {
            showNotification('Not enough resources or inventory full!');
            renderShop();
        });

        socket.on('removePlayer', (id) => {
            const op = otherPlayers.get(id);
            if (op) {
                scene.remove(op.group);
                otherPlayers.delete(id);
            }
        });

        socket.on('respawn', (data) => {
            camera.position.set(data.pos.x, data.pos.y, data.pos.z);
            camera.rotation.set(data.rot.pitch, data.rot.yaw, 0);
            velocity.set(0, 0, 0);
        });

        // NEW: Bed destruction - just show notification, block removal handled by server
        socket.on('bedDestroyed', () => {
            showNotification('Your bed was destroyed!');
        });

        socket.on('notification', (msg) => {
            showNotification(msg);
        });

        socket.on('countdown', (sec) => {
            showNotification(`Starting in ${sec}`, 1100);
            updateWaitingMessage(0); // Hide waiting message
        });

        socket.on('gameStart', () => {
            showNotification('GO!');
            isInRound = true;
            startRoundTimer(900); // 15 minutes
        });

        socket.on('gameEnd', ({ winner }) => {
            if (winner === playerId) {
                showNotification('You Win!', 5000);
            } else {
                showNotification(`Player ${winner.substring(0,6)} Wins!`, 5000);
            }
            isInRound = false;
            stopRoundTimer();
        });

        socket.on('worldReset', (data) => {
            blocksInScene.forEach((m) => scene.remove(m));
            blocksInScene.length = 0;
            blocksMeshes.clear();
            resourcePickups.forEach((m) => scene.remove(m));
            resourcePickups.length = 0;
            pickupMeshes.clear();
            resourceSpawners.forEach((m) => scene.remove(m));
            resourceSpawners.length = 0;
            data.blocks.forEach(({ x, y, z, type }) => addBlockMesh(x, y, z, type));
            data.pickups.forEach(addPickupMesh);
            data.spawners.forEach((s) => addResourceSpawner(s.x, s.y, s.z, s.resourceType, s.interval / 1000));
        });

        socket.on('playerReset', (data) => {
            camera.position.set(data.pos.x, data.pos.y, data.pos.z);
            camera.rotation.set(data.rot.pitch, data.rot.yaw, 0);
            inventory = data.inventory;
            currency = data.currency;
            updateUI();
            velocity.set(0, 0, 0);
            setSpectatorMode(false); // Reset spectator mode
        });

        // NEW: Set spectator mode
        socket.on('setSpectator', (spectator) => {
            setSpectatorMode(spectator);
        });

        // NEW: Update waiting message
        socket.on('updateWaiting', (playersNeeded) => {
            updateWaitingMessage(playersNeeded);
        });

        // NEW: Update timer
        socket.on('updateTimer', (timeRemaining) => {
            roundTimeRemaining = timeRemaining;
            updateTimerDisplay(timeRemaining);
            if (timeRemaining > 0) {
                document.getElementById('timer').style.display = 'block';
            } else {
                document.getElementById('timer').style.display = 'none';
            }
        });

        selectSlot(0);
        updateUI();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
