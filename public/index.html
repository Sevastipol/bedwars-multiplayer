<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Island Builder - Multiplayer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 10;
        }

        #timer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        #stats {
            position: absolute;
            top: 80px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
        }

        .currency-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 1.2em;
            font-weight: bold;
        }

        .currency-icon {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            image-rendering: pixelated;
        }

        #item-name-overlay {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            text-shadow: 0px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            z-index: 15;
        }

        #break-progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 20px);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid white;
            border-radius: 4px;
            display: none;
            overflow: hidden;
        }

        #break-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4d9043, #7bc96f);
            width: 0%;
            transition: width 0.1s linear;
        }

        #hotbar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .inv-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #444;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
        }

        .inv-slot.active {
            border-color: white;
            transform: scale(1.1);
            background: rgba(50, 50, 50, 0.8);
        }

        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
        }

        .slot-key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #aaa;
        }

        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 16, 16, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            display: none;
            text-align: center;
            border: 2px solid #555;
            min-width: 450px;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .shop-item {
            padding: 15px;
            border: 1px solid #444;
            cursor: pointer;
            background: #222;
            transition: 0.2s;
        }

        .shop-item:hover {
            background: #333;
            border-color: #fff;
        }

        .shop-item:active {
            background: #444;
        }

        .shop-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .block-icon {
            width: 20px;
            height: 20px;
            border: 1px solid rgba(255,255,255,0.3);
            image-rendering: pixelated;
        }

        .shop-icon {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            margin: 0 auto 10px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        #controls-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ccc;
            font-size: 12px;
            text-align: right;
            text-shadow: 1px 1px 2px black;
        }

        .crouch-indicator {
            color: #ffff88 !important;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 100;
        }

        #notification {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 30px;
            text-shadow: 2px 2px 4px black;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            display: none;
            z-index: 15;
        }

        #spectator-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5555;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,85,85,0.7);
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 15px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }

        #waiting-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff88;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,136,0.7);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 15px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        #fullscreen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
            font-size: 24px;
            text-align: center;
        }
        
        #fullscreen-overlay button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        #fullscreen-overlay button:hover {
            background: #45a049;
        }

        .health-bar {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: rgba(0,0,0,0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: #4CAF50;
            width: 100%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Fullscreen Overlay -->
    <div id="fullscreen-overlay" style="display: block;">
        <h2>Island Builder Multiplayer</h2>
        <p>Click the button below to enter fullscreen mode</p>
        <button id="enter-fullscreen">Enter Fullscreen</button>
    </div>
    
    <!-- Timer Display -->
    <div id="timer">15:00</div>
    
    <!-- Spectator Indicator -->
    <div id="spectator-indicator">SPECTATOR MODE</div>
    
    <!-- Waiting Message -->
    <div id="waiting-message"></div>
    
    <!-- Game Elements -->
    <div id="loading">Connecting to server...</div>
    <div id="crosshair"></div>
    <div id="stats">
        <div class="currency-row">
            <img src="https://i.ibb.co/n87Ym7RY/pixilart-drawing-7.png" class="currency-icon">
            <span id="iron">0</span>
        </div>
        <div class="currency-row">
            <img src="https://i.ibb.co/27GwzjkT/pixilart-drawing-6.png" class="currency-icon">
            <span id="gold">0</span>
        </div>
        <div class="currency-row">
            <img src="https://i.ibb.co/hxX4ywxj/pixilart-drawing-8.png" class="currency-icon">
            <span id="emerald">0</span>
        </div>
    </div>
    <div id="controls-hint">
        WASD: Move | SPACE: Jump<br>
        <span id="crouch-hint">SHIFT: Crouch</span> | 1-9: Select<br>
        B: Shop | ESC: Unlock Mouse<br>
        <span style="color: #ff8888">Hold L-Click: Break</span><br>
        <span style="color: #88ff88">R-Click: Build</span><br>
        <span style="color: #88aaff">Right-Click with Enderpearl: Throw</span><br>
        <span style="color: #ffaa00">Right-Click with Fireball: Throw (Destroys blocks)</span><br>
        <span style="color: #ff88ff">Click on Players: Attack</span>
    </div>
    <div id="break-progress">
        <div id="break-progress-bar"></div>
    </div>
    <div id="item-name-overlay"></div>
    <div id="hotbar-container"></div>
    <div id="shop">
        <h2>Shop</h2>
        <div style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">Click to buy items</div>
        <div class="shop-grid" id="shop-container"></div>
        <p style="color: #888; margin-top: 20px; font-size: 0.8em;">Press [B] to Close</p>
    </div>
    <div id="notification"></div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const socket = io({ reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000 });

        // Hide loading when connected
        socket.on('connect', () => {
            document.getElementById('loading').style.display = 'none';
        });

        // --- Game State ---
        let isSpectator = true;
        let roundTimeRemaining = 900;
        let roundTimerInterval = null;
        let isInRound = false;
        let wasBuying = false;
        let lastEnderpearlThrow = 0;
        let lastFireballThrow = 0;

        // --- Config ---
        const BLOCK_TYPES = {
            'Grass': { color: 0x4d9043, cost: { iron: 5 }, breakTime: 1.2, buyAmount: 8, hasTexture: true },
            'Glass': { color: 0xade8f4, cost: { iron: 5 }, breakTime: 0.4, buyAmount: 16, opacity: 0.6 },
            'Wood': { color: 0x5d4037, cost: { gold: 5 }, breakTime: 3, buyAmount: 32, hasTexture: true },
            'Stone': { color: 0x777777, cost: { gold: 5 }, breakTime: 6, buyAmount: 8, hasTexture: true },
            'Obsidian': { color: 0x111111, cost: { emerald: 1 }, breakTime: 12, buyAmount: 1, hasTexture: true },
            'Bed': { color: 0xff0000, breakTime: 0.8, buyAmount: 1, hasTexture: false },
            'Enderpearl': { color: 0x00ff88, cost: { emerald: 2 }, buyAmount: 1, isItem: true, hasTexture: true },
            'Fireball': { color: 0xff5500, cost: { iron: 48 }, buyAmount: 1, isItem: true, hasTexture: true },
            'Wooden Sword': { color: 0x8B4513, cost: { iron: 20 }, buyAmount: 1, isItem: true, isWeapon: true, damage: 2, hasTexture: true },
            'Iron Sword': { color: 0xC0C0C0, cost: { gold: 10 }, buyAmount: 1, isItem: true, isWeapon: true, damage: 3, hasTexture: true },
            'Emerald Sword': { color: 0x00FF00, cost: { emerald: 5 }, buyAmount: 1, isItem: true, isWeapon: true, damage: 4, hasTexture: true }
        };
        const MAX_STACK = 64;
        const INVENTORY_SIZE = 9;

        // --- State ---
        let currency = { iron: 0, gold: 0, emerald: 0 };
        let inventory = new Array(INVENTORY_SIZE).fill(null);
        let selectedSlotIndex = 0;
        let overlayTimeout;

        const blocksInScene = [];
        const resourceSpawners = [];
        const resourcePickups = [];
        const projectiles = new Map();
        const fireballProjectiles = new Map();
        
        // Breaking overlays for other players
        const breakingOverlays = new Map();

        // Breaking state
        let isBreaking = false;
        let breakingBlock = null;
        let breakingStartTime = 0;
        let breakingDuration = 0;
        let breakingOverlay = null;

        // Crouching state
        let isCrouching = false;

        // Sword in hand
        let swordInHand = null;

        let playerId = null;
        let blocksMeshes = new Map();
        let pickupMeshes = new Map();
        let otherPlayers = new Map();
        let playerHealth = new Map();
        let playerSwords = new Map();

        // --- Fullscreen Functions ---
        function enterFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
            
            document.getElementById('fullscreen-overlay').style.display = 'none';
            
            setTimeout(() => {
                if (!controls.isLocked && !isShopOpen()) {
                    controls.lock();
                }
            }, 500);
        }

        function isFullscreen() {
            return document.fullscreenElement || 
                   document.webkitFullscreenElement || 
                   document.msFullscreenElement;
        }

        document.getElementById('enter-fullscreen').addEventListener('click', enterFullscreen);
        
        document.getElementById('fullscreen-overlay').addEventListener('click', (e) => {
            if (e.target.id !== 'enter-fullscreen') {
                enterFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (isFullscreen()) {
                document.getElementById('fullscreen-overlay').style.display = 'none';
            }
        });

        document.addEventListener('webkitfullscreenchange', () => {
            if (isFullscreen()) {
                document.getElementById('fullscreen-overlay').style.display = 'none';
            }
        });

        // --- Timer Functions ---
        function updateTimerDisplay(seconds) {
            const timerElement = document.getElementById('timer');
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            timerElement.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function startRoundTimer(initialTime) {
            roundTimeRemaining = initialTime;
            updateTimerDisplay(roundTimeRemaining);
            document.getElementById('timer').style.display = 'block';
            
            if (roundTimerInterval) clearInterval(roundTimerInterval);
            
            roundTimerInterval = setInterval(() => {
                if (isInRound && roundTimeRemaining > 0) {
                    roundTimeRemaining--;
                    updateTimerDisplay(roundTimeRemaining);
                    
                    if (roundTimeRemaining <= 0) {
                        clearInterval(roundTimerInterval);
                        document.getElementById('timer').style.display = 'none';
                    }
                }
            }, 1000);
        }

        function stopRoundTimer() {
            if (roundTimerInterval) {
                clearInterval(roundTimerInterval);
                roundTimerInterval = null;
            }
            document.getElementById('timer').style.display = 'none';
        }

        // --- Spectator Functions ---
        function setSpectatorMode(spectator) {
            isSpectator = spectator;
            const indicator = document.getElementById('spectator-indicator');
            
            if (spectator) {
                indicator.style.display = 'block';
                document.getElementById('stats').style.display = 'none';
                document.getElementById('hotbar-container').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('controls-hint').style.display = 'none';
                document.getElementById('break-progress').style.display = 'none';
                document.getElementById('timer').style.display = 'none';
                velocity.y = 0;
                onGround = true;
                
                // Remove sword from hand
                if (swordInHand) {
                    scene.remove(swordInHand);
                    swordInHand = null;
                }
                
                if (isFullscreen() && !controls.isLocked && !isShopOpen()) {
                    setTimeout(() => {
                        if (!controls.isLocked && !isShopOpen()) {
                            controls.lock();
                        }
                    }, 100);
                }
            } else {
                indicator.style.display = 'none';
                document.getElementById('stats').style.display = 'block';
                document.getElementById('hotbar-container').style.display = 'flex';
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('controls-hint').style.display = 'block';
                if (isInRound) {
                    document.getElementById('timer').style.display = 'block';
                }
                
                // Update sword in hand
                updateSwordInHand();
                
                if (isFullscreen() && !controls.isLocked && !isShopOpen()) {
                    setTimeout(() => {
                        if (!controls.isLocked && !isShopOpen()) {
                            controls.lock();
                        }
                    }, 100);
                }
            }
        }

        // --- Waiting Message Function ---
        function updateWaitingMessage(playersNeeded) {
            const messageElement = document.getElementById('waiting-message');
            if (playersNeeded > 0) {
                messageElement.textContent = `Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''}...`;
                messageElement.style.display = 'block';
            } else {
                messageElement.style.display = 'none';
            }
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6eb1ff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(20, 50, 20);
        scene.add(sun);

        // Load textures
        const textureLoader = new THREE.TextureLoader();
        let grassTexture = null;
        let woodTexture = null;
        let stoneTexture = null;
        let obsidianTexture = null;
        let ironTexture = null;
        let goldTexture = null;
        let emeraldTexture = null;
        let enderpearlTexture = null;
        let fireballTexture = null;
        let woodenSwordTexture = null;
        let ironSwordTexture = null;
        let emeraldSwordTexture = null;
        let breakingTextures = [];

        // Texture URLs
        const TEXTURE_URLS = {
            grass: 'https://i.ibb.co/394nfmMz/pixilart-drawing-3.png',
            wood: 'https://i.ibb.co/KpWBZRPS/pixilart-drawing-2.png',
            stone: 'https://i.ibb.co/rGVR38xv/pixilart-drawing-5.png',
            obsidian: 'https://i.ibb.co/bRdZdGR2/pixilart-drawing-4.png',
            iron: 'https://i.ibb.co/n87Ym7RY/pixilart-drawing-7.png',
            gold: 'https://i.ibb.co/27GwzjkT/pixilart-drawing-6.png',
            emerald: 'https://i.ibb.co/hxX4ywxj/pixilart-drawing-8.png',
            enderpearl: 'https://i.ibb.co/TBmwYFGG/pixil-frame-0-9.png',
            fireball: 'https://i.ibb.co/Kc4xPxSJ/pixilart-drawing-9.png',
            woodenSword: 'https://i.ibb.co/mLZmwsJ/pixil-frame-0-10.png',
            ironSword: 'https://i.ibb.co/F4NZLPzj/pixil-frame-0-11.png',
            emeraldSword: 'https://i.ibb.co/przKkdMP/pixil-frame-0-12.png'
        };

        // Load textures
        textureLoader.load(TEXTURE_URLS.grass, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            grassTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.wood, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            woodTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.stone, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            stoneTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.obsidian, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            obsidianTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.iron, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            ironTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.gold, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            goldTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.emerald, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            emeraldTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.enderpearl, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            enderpearlTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.fireball, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            fireballTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.woodenSword, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            woodenSwordTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.ironSword, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            ironSwordTexture = texture;
        });

        textureLoader.load(TEXTURE_URLS.emeraldSword, (texture) => {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            emeraldSwordTexture = texture;
        });

        // Load breaking textures
        const breakingTextureUrls = [
            'https://i.ibb.co/hxcqsNSc/pixil-frame-0.png',
            'https://i.ibb.co/9ms6601B/pixil-frame-0-1.png',
            'https://i.ibb.co/Ng24qysY/pixil-frame-0-2.png',
            'https://i.ibb.co/ccsc9WQg/pixil-frame-0-3.png',
            'https://i.ibb.co/YBqh6x4w/pixil-frame-0-4.png',
            'https://i.ibb.co/NnsSg1sL/pixil-frame-0-5.png',
            'https://i.ibb.co/5HCS1DL/pixil-frame-0-6.png',
            'https://i.ibb.co/PGxn1rDt/pixil-frame-0-7.png',
            'https://i.ibb.co/4wfn1SFL/pixil-frame-0-8.png'
        ];

        const loadBreakingTextures = async () => {
            for (let i = 0; i < breakingTextureUrls.length; i++) {
                await new Promise((resolve) => {
                    textureLoader.load(breakingTextureUrls[i], (texture) => {
                        texture.magFilter = THREE.NearestFilter;
                        texture.minFilter = THREE.NearestFilter;
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        breakingTextures[i] = texture;
                        resolve();
                    });
                });
            }
        };
        loadBreakingTextures();

        // --- World Generation ---
        function addBlockMesh(x, y, z, type) {
            const blockData = BLOCK_TYPES[type];
            let material;
            if (type === 'Grass' && grassTexture) {
                material = new THREE.MeshLambertMaterial({ map: grassTexture });
            } else if (type === 'Wood' && woodTexture) {
                material = new THREE.MeshLambertMaterial({ map: woodTexture });
            } else if (type === 'Stone' && stoneTexture) {
                material = new THREE.MeshLambertMaterial({ map: stoneTexture });
            } else if (type === 'Obsidian' && obsidianTexture) {
                material = new THREE.MeshLambertMaterial({ map: obsidianTexture });
            } else {
                material = new THREE.MeshLambertMaterial({ color: blockData.color, transparent: !!blockData.opacity, opacity: blockData.opacity || 1 });
            }
            const voxel = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
            voxel.position.set(x + 0.5, y + 0.5, z + 0.5);
            voxel.userData = { type: type };
            scene.add(voxel);
            blocksInScene.push(voxel);
            const key = `${x},${y},${z}`;
            blocksMeshes.set(key, voxel);
            return voxel;
        }

        function removeBlockMesh(x, y, z) {
            const key = `${x},${y},${z}`;
            const mesh = blocksMeshes.get(key);
            if (mesh) {
                scene.remove(mesh);
                const idx = blocksInScene.indexOf(mesh);
                if (idx > -1) blocksInScene.splice(idx, 1);
                blocksMeshes.delete(key);
            }
        }

        // --- Enderpearl Functions ---
        function createEnderpearlMesh(data) {
            let material;
            if (enderpearlTexture) {
                material = new THREE.SpriteMaterial({ 
                    map: enderpearlTexture,
                    transparent: true,
                    opacity: 0.9,
                    rotation: 0
                });
            } else {
                material = new THREE.SpriteMaterial({ 
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
            }
            
            const pearl = new THREE.Sprite(material);
            pearl.position.set(data.x, data.y, data.z);
            pearl.scale.set(0.5, 0.5, 1);
            
            pearl.userData = { 
                id: data.id, 
                type: 'enderpearl',
                owner: data.owner,
                velocity: data.velocity,
                lastUpdate: Date.now(),
                lastPos: { x: data.x, y: data.y, z: data.z }
            };
            
            scene.add(pearl);
            projectiles.set(data.id, pearl);
            return pearl;
        }

        function updateEnderpearl(pearlData) {
            const pearl = projectiles.get(pearlData.id);
            if (pearl) {
                if (pearl.userData.lastPos) {
                    const lerpFactor = 0.3;
                    pearl.position.x = THREE.MathUtils.lerp(
                        pearl.position.x,
                        pearlData.x,
                        lerpFactor
                    );
                    pearl.position.y = THREE.MathUtils.lerp(
                        pearl.position.y,
                        pearlData.y,
                        lerpFactor
                    );
                    pearl.position.z = THREE.MathUtils.lerp(
                        pearl.position.z,
                        pearlData.z,
                        lerpFactor
                    );
                } else {
                    pearl.position.set(pearlData.x, pearlData.y, pearlData.z);
                }
            }
        }

        function removeEnderpearlMesh(id) {
            const pearl = projectiles.get(id);
            if (pearl) {
                scene.remove(pearl);
                if (pearl.material) pearl.material.dispose();
                projectiles.delete(id);
            }
        }

        // --- Fireball Functions ---
        function createFireballMesh(data) {
            let material;
            if (fireballTexture) {
                material = new THREE.SpriteMaterial({ 
                    map: fireballTexture,
                    color: 0xaaaaaa,
                    opacity: 1.0,
                    transparent: true
                });
            } else {
                material = new THREE.SpriteMaterial({ 
                    color: 0xaaaaaa,
                    opacity: 1.0,
                    transparent: true
                });
            }
            
            const fireball = new THREE.Sprite(material);
            fireball.position.set(data.x, data.y, data.z);
            fireball.scale.set(0.8, 0.8, 1);
            
            fireball.userData = { 
                id: data.id, 
                type: 'fireball',
                owner: data.owner,
                velocity: data.velocity,
                lastUpdate: Date.now(),
                lastPos: { x: data.x, y: data.y, z: data.z }
            };
            
            scene.add(fireball);
            fireballProjectiles.set(data.id, fireball);
            return fireball;
        }

        function updateFireballMesh(fireballData) {
            const fireball = fireballProjectiles.get(fireballData.id);
            if (fireball) {
                if (fireball.userData.lastPos) {
                    const lerpFactor = 0.3;
                    fireball.position.x = THREE.MathUtils.lerp(
                        fireball.position.x,
                        fireballData.x,
                        lerpFactor
                    );
                    fireball.position.y = THREE.MathUtils.lerp(
                        fireball.position.y,
                        fireballData.y,
                        lerpFactor
                    );
                    fireball.position.z = THREE.MathUtils.lerp(
                        fireball.position.z,
                        fireballData.z,
                        lerpFactor
                    );
                } else {
                    fireball.position.set(fireballData.x, fireballData.y, fireballData.z);
                }
            }
        }

        function removeFireballMesh(id) {
            const fireball = fireballProjectiles.get(id);
            if (fireball) {
                scene.remove(fireball);
                if (fireball.material) fireball.material.dispose();
                fireballProjectiles.delete(id);
            }
        }

        // Fireball explosion effect
        function createFireballExplosion(x, y, z) {
            const particleCount = 30;
            const explosionGroup = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: Math.random() > 0.5 ? 0xff5500 : 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                particle.userData.velocity = {
                    x: Math.cos(angle) * speed,
                    y: Math.random() * speed,
                    z: Math.sin(angle) * speed
                };
                particle.userData.life = 1.0;
                particle.userData.decay = 0.05 + Math.random() * 0.05;
                
                particle.position.set(x + 0.5, y + 0.5, z + 0.5);
                explosionGroup.add(particle);
            }
            
            scene.add(explosionGroup);
            
            function animateExplosion() {
                let allDead = true;
                
                explosionGroup.children.forEach(particle => {
                    particle.userData.life -= particle.userData.decay;
                    
                    if (particle.userData.life > 0) {
                        allDead = false;
                        particle.position.x += particle.userData.velocity.x * 0.1;
                        particle.position.y += particle.userData.velocity.y * 0.1;
                        particle.position.z += particle.userData.velocity.z * 0.1;
                        particle.material.opacity = particle.userData.life;
                        particle.scale.setScalar(particle.userData.life);
                    }
                });
                
                if (!allDead) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosionGroup);
                    explosionGroup.children.forEach(particle => {
                        particle.geometry.dispose();
                        particle.material.dispose();
                    });
                }
            }
            
            animateExplosion();
        }

        // --- Sword Functions ---
        function createSwordMesh(type, playerId = null) {
            let texture = null;
            if (type === 'Wooden Sword' && woodenSwordTexture) texture = woodenSwordTexture;
            else if (type === 'Iron Sword' && ironSwordTexture) texture = ironSwordTexture;
            else if (type === 'Emerald Sword' && emeraldSwordTexture) texture = emeraldSwordTexture;
            
            if (!texture) return null;
            
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            
            const sword = new THREE.Sprite(material);
            
            if (playerId) {
                sword.userData = { type: 'sword', playerId: playerId, swordType: type };
            }
            
            return sword;
        }

        function updateSwordInHand() {
            if (swordInHand) {
                scene.remove(swordInHand);
                swordInHand = null;
            }
            
            const currentSlot = inventory[selectedSlotIndex];
            if (currentSlot && currentSlot.type && BLOCK_TYPES[currentSlot.type] && BLOCK_TYPES[currentSlot.type].isWeapon) {
                // Don't create sword for local player
                // swordInHand = createSwordMesh(currentSlot.type);
                // if (swordInHand) {
                //     swordInHand.position.set(-0.4, -0.3, -0.5);
                //     swordInHand.scale.set(1.0, 1.0, 1);
                //     scene.add(swordInHand);
                // }
            }
        }

        function updateOtherPlayerSword(playerId, swordType) {
            const op = otherPlayers.get(playerId);
            if (!op || !op.group) return;
            
            if (playerSwords.has(playerId)) {
                const oldSword = playerSwords.get(playerId);
                op.group.remove(oldSword);
                playerSwords.delete(playerId);
            }
            
            if (swordType && BLOCK_TYPES[swordType] && BLOCK_TYPES[swordType].isWeapon) {
                const sword = createSwordMesh(swordType, playerId);
                if (sword) {
                    sword.position.set(-0.7, 0.8, 0.2);
                    sword.scale.set(0.8, 0.8, 1);
                    
                    op.group.add(sword);
                    playerSwords.set(playerId, sword);
                }
            }
        }

        // --- Breaking Animation Functions for Other Players ---
        function createOtherPlayerBreakingOverlay(x, y, z, progress) {
            const key = `${x},${y},${z}`;
            
            if (breakingOverlays.has(key)) {
                const existing = breakingOverlays.get(key);
                scene.remove(existing.mesh);
                breakingOverlays.delete(key);
            }
            
            if (breakingTextures.length > 0) {
                const textureIndex = Math.min(Math.floor(progress * 9), 8);
                const overlayMaterial = new THREE.MeshBasicMaterial({
                    map: breakingTextures[textureIndex],
                    transparent: true,
                    opacity: 0.8,
                    depthWrite: false
                });
                const overlay = new THREE.Mesh(
                    new THREE.BoxGeometry(1.01, 1.01, 1.01),
                    overlayMaterial
                );
                overlay.position.set(x + 0.5, y + 0.5, z + 0.5);
                scene.add(overlay);
                
                breakingOverlays.set(key, {
                    mesh: overlay,
                    progress: progress,
                    lastUpdate: Date.now()
                });
            }
        }

        function updateOtherPlayerBreakingOverlay(x, y, z, progress) {
            const key = `${x},${y},${z}`;
            
            if (breakingOverlays.has(key)) {
                const data = breakingOverlays.get(key);
                data.progress = progress;
                data.lastUpdate = Date.now();
                
                if (breakingTextures.length > 0) {
                    const textureIndex = Math.min(Math.floor(progress * 9), 8);
                    data.mesh.material.map = breakingTextures[textureIndex];
                    data.mesh.material.needsUpdate = true;
                }
            } else {
                createOtherPlayerBreakingOverlay(x, y, z, progress);
            }
        }

        function removeOtherPlayerBreakingOverlay(x, y, z) {
            const key = `${x},${y},${z}`;
            
            if (breakingOverlays.has(key)) {
                const data = breakingOverlays.get(key);
                scene.remove(data.mesh);
                breakingOverlays.delete(key);
            }
        }

        // Clean up old breaking overlays
        function cleanupOldBreakingOverlays() {
            const now = Date.now();
            const toRemove = [];
            
            breakingOverlays.forEach((data, key) => {
                if (now - data.lastUpdate > 5000) {
                    toRemove.push(key);
                }
            });
            
            toRemove.forEach(key => {
                const data = breakingOverlays.get(key);
                scene.remove(data.mesh);
                breakingOverlays.delete(key);
            });
        }

        // --- Resource Spawners ---
        function addResourceSpawner(x, y, z, resourceType, interval, lastSpawn = null) {
            const colors = { iron: 0xa0a0a0, gold: 0xffd700, emerald: 0x00ff88 };
            const spawner = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: colors[resourceType],
                    emissive: colors[resourceType],
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                })
            );
            spawner.position.set(x, y, z);
            
            const spawnerData = {
                type: 'spawner',
                resourceType: resourceType,
                interval: interval * 1000,
                lastSpawn: lastSpawn || Date.now(),
                x: x, y: y, z: z,
                id: `${x}-${y}-${z}-${resourceType}`,
                count: 0,
                textSprite: null,
                textTexture: null
            };
            spawner.userData = spawnerData;
            
            createGeneratorText(spawner);
            
            scene.add(spawner);
            resourceSpawners.push(spawner);
            return spawner;
        }

        function createGeneratorText(spawner) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.set(spawner.position.x, spawner.position.y + 1.5, spawner.position.z);
            sprite.scale.set(0.8, 0.4, 1);
            sprite.userData = { type: 'generator_text', spawnerId: spawner.userData.id };
            
            scene.add(sprite);
            spawner.userData.textSprite = sprite;
            spawner.userData.textTexture = texture;
            
            return sprite;
        }

        function updateGeneratorText(spawner) {
            if (!spawner.userData.textSprite || !spawner.userData.textTexture) return;
            
            let resourceCount = 0;
            resourcePickups.forEach(pickup => {
                if (pickup.userData.resourceType === spawner.userData.resourceType) {
                    const dx = Math.abs(pickup.position.x - spawner.position.x);
                    const dz = Math.abs(pickup.position.z - spawner.position.z);
                    if (dx < 2 && dz < 2 && pickup.position.y < spawner.position.y + 1) {
                        resourceCount++;
                    }
                }
            });
            
            spawner.userData.count = resourceCount;
            
            const canvas = spawner.userData.textTexture.image;
            const context = canvas.getContext('2d');
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = '#ffffff';
            context.fillText(resourceCount.toString(), canvas.width / 2, canvas.height / 2);
            
            spawner.userData.textTexture.needsUpdate = true;
        }

        function addPickupMesh(data) {
            const size = 0.6;
            const geometry = new THREE.BoxGeometry(size, size, size);

            let texture = null;
            if (data.resourceType === 'iron') texture = ironTexture;
            else if (data.resourceType === 'gold') texture = goldTexture;
            else if (data.resourceType === 'emerald') texture = emeraldTexture;

            const materials = [
                new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 }),
                new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 }),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 }),
                new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.3 }),
                texture ? new THREE.MeshBasicMaterial({ map: texture, transparent: true }) : new THREE.MeshBasicMaterial({ color: 0x888888 }),
                new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 })
            ];

            const pickup = new THREE.Mesh(geometry, materials);
            pickup.position.set(data.x, data.y, data.z);
            pickup.userData = { type: 'resource_pickup', resourceType: data.resourceType, spawnTime: Date.now(), baseY: data.y, id: data.id };
            scene.add(pickup);
            resourcePickups.push(pickup);
            pickupMeshes.set(data.id, pickup);
        }

        function removePickupMesh(id) {
            const mesh = pickupMeshes.get(id);
            if (mesh) {
                scene.remove(mesh);
                const idx = resourcePickups.indexOf(mesh);
                if (idx > -1) resourcePickups.splice(idx, 1);
                pickupMeshes.delete(id);
            }
        }

        // --- Physics & Controls ---
        const PLAYER_HEIGHT = 1.8;
        const EYE_HEIGHT = 1.6;
        const CROUCH_HEIGHT = 1.3;
        const PLAYER_RADIUS = 0.4;

        camera.position.set(-12, 5, -12);
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        const moveState = { fwd: false, bwd: false, l: false, r: false };
        let onGround = false;

        function isShopOpen() {
            return document.getElementById('shop').style.display === 'block';
        }

        // Block breaking cancellation
        function isStillLookingAtBlock() {
            if (!isBreaking || !breakingBlock) return false;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(blocksInScene);
            
            if (intersects.length === 0) return false;
            
            const intersect = intersects[0];
            
            const sameBlock = intersect.object === breakingBlock;
            
            const inRange = intersect.distance <= 5;
            
            return sameBlock && inRange;
        }

        document.addEventListener('keydown', (e) => {
            if (!isFullscreen()) return;
            
            if (isSpectator) {
                if(e.code === 'KeyB') return;
                
                switch(e.code) {
                    case 'KeyW': moveState.fwd = true; break;
                    case 'KeyS': moveState.bwd = true; break;
                    case 'KeyA': moveState.l = true; break;
                    case 'KeyD': moveState.r = true; break;
                    case 'Space': velocity.y = 5; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': velocity.y = -5; break;
                }
                return;
            }

            if(e.code === 'KeyB') toggleShop();
            if(document.getElementById('shop').style.display === 'block') return;

            if (e.code.startsWith('Digit') && e.code !== 'Digit0') {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 9) {
                    selectSlot(num - 1);
                }
            }

            switch(e.code) {
                case 'KeyW': moveState.fwd = true; break;
                case 'KeyS': moveState.bwd = true; break;
                case 'KeyA': moveState.l = true; break;
                case 'KeyD': moveState.r = true; break;
                case 'Space':
                    if(onGround && !isCrouching) {
                        velocity.y = 7.5;
                        onGround = false;
                    } else if (onGround && isCrouching) {
                        velocity.y = 6;
                        onGround = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    e.preventDefault();
                    if (!isCrouching) {
                        isCrouching = true;
                        document.getElementById('crouch-hint').classList.add('crouch-indicator');
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!isFullscreen()) return;
            
            if (isSpectator) {
                switch(e.code) {
                    case 'KeyW': moveState.fwd = false; break;
                    case 'KeyS': moveState.bwd = false; break;
                    case 'KeyA': moveState.l = false; break;
                    case 'KeyD': moveState.r = false; break;
                    case 'Space':
                    case 'ShiftLeft':
                    case 'ShiftRight': velocity.y = 0; break;
                }
                return;
            }

            switch(e.code) {
                case 'KeyW': moveState.fwd = false; break;
                case 'KeyS': moveState.bwd = false; break;
                case 'KeyA': moveState.l = false; break;
                case 'KeyD': moveState.r = false; break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isCrouching = false;
                    document.getElementById('crouch-hint').classList.remove('crouch-indicator');
                    break;
            }
        });

        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousedown', (e) => {
            if (!isFullscreen()) {
                enterFullscreen();
                return;
            }
            
            if (isSpectator) {
                if (!controls.isLocked && !isShopOpen()) {
                    controls.lock();
                }
                return;
            }
            
            if (!controls.isLocked) {
                if(!isShopOpen()) controls.lock();
                return;
            }

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            if (e.button === 0) {
                const playerObjects = Array.from(otherPlayers.values())
                    .filter(op => !op.spectator)
                    .map(op => op.group);
                
                if (playerObjects.length > 0) {
                    const playerIntersects = raycaster.intersectObjects(playerObjects, true);
                    
                    if (playerIntersects.length > 0) {
                        const intersect = playerIntersects[0];
                        if (intersect.distance > 5) {
                            socket.emit('notification', 'Too far away!');
                            return;
                        }
                        
                        let obj = intersect.object;
                        while (obj && !otherPlayers.has(obj.name)) {
                            obj = obj.parent;
                        }
                        
                        if (obj && otherPlayers.has(obj.name)) {
                            socket.emit('hitPlayer', obj.name);
                            return;
                        }
                    }
                }
                
                const blockIntersects = raycaster.intersectObjects(blocksInScene);
                if (blockIntersects.length > 0) {
                    const intersect = blockIntersects[0];
                    const obj = intersect.object;
                    
                    if (intersect.distance > 5) {
                        socket.emit('notification', 'Too far away!');
                        return;
                    }
                    
                    if (obj.userData.type !== 'spawner') {
                        const type = obj.userData.type || 'Grass';
                        isBreaking = true;
                        breakingBlock = obj;
                        breakingStartTime = Date.now();
                        breakingDuration = BLOCK_TYPES[type].breakTime * 1000;
                        document.getElementById('break-progress').style.display = 'block';
                        
                        const x = Math.floor(breakingBlock.position.x - 0.5);
                        const y = Math.floor(breakingBlock.position.y - 0.5);
                        const z = Math.floor(breakingBlock.position.z - 0.5);
                        
                        socket.emit('startBreaking', {
                            x, y, z,
                            type: type,
                            breakTime: breakingDuration
                        });
                        
                        if (!breakingOverlay && breakingTextures.length > 0) {
                            const overlayMaterial = new THREE.MeshBasicMaterial({
                                map: breakingTextures[0],
                                transparent: true,
                                opacity: 0.8,
                                depthWrite: false
                            });
                            breakingOverlay = new THREE.Mesh(
                                new THREE.BoxGeometry(1.01, 1.01, 1.01),
                                overlayMaterial
                            );
                            breakingOverlay.position.copy(obj.position);
                            scene.add(breakingOverlay);
                        }
                    }
                }
            } else if (e.button === 2) {
                const currentSlot = inventory[selectedSlotIndex];
                
                if (currentSlot && currentSlot.type === 'Enderpearl' && currentSlot.count > 0) {
                    const now = Date.now();
                    if (now - lastEnderpearlThrow < 1000) {
                        socket.emit('notification', 'Enderpearl cooldown!');
                        return;
                    }
                    
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(camera.quaternion);
                    direction.normalize();
                    
                    const throwDistance = 50;
                    const targetPos = {
                        x: camera.position.x + direction.x * throwDistance,
                        y: camera.position.y + direction.y * throwDistance,
                        z: camera.position.z + direction.z * throwDistance
                    };
                    
                    socket.emit('throwEnderpearl', targetPos);
                    lastEnderpearlThrow = now;
                    return;
                }
                
                else if (currentSlot && currentSlot.type === 'Fireball' && currentSlot.count > 0) {
                    const now = Date.now();
                    if (now - lastFireballThrow < 100) {
                        socket.emit('notification', 'Fireball cooldown!');
                        return;
                    }
                    
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(camera.quaternion);
                    direction.normalize();
                    
                    const throwDistance = 50;
                    const targetPos = {
                        x: camera.position.x + direction.x * throwDistance,
                        y: camera.position.y + direction.y * throwDistance,
                        z: camera.position.z + direction.z * throwDistance
                    };
                    
                    socket.emit('throwFireball', targetPos);
                    lastFireballThrow = now;
                    return;
                }
                
                const blockIntersects = raycaster.intersectObjects(blocksInScene);
                if (blockIntersects.length > 0 && currentSlot && currentSlot.count > 0) {
                    const intersect = blockIntersects[0];
                    if (intersect.distance > 5) {
                        socket.emit('notification', 'Too far away!');
                        return;
                    }
                    const pos = intersect.point.clone().add(intersect.face.normal.multiplyScalar(0.5));

                    const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                    const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;

                    const blockX = Math.floor(pos.x);
                    const blockY = Math.floor(pos.y);
                    const blockZ = Math.floor(pos.z);

                    let canPlace = true;
                    const playerFeetY = camera.position.y - currentEyeHeight;
                    const playerHeadY = camera.position.y - currentEyeHeight + currentPlayerHeight;
                    const blockMinY = blockY;
                    const blockMaxY = blockY + 1;
                    if (blockMaxY > playerFeetY && blockMinY < playerHeadY) {
                        const dx = Math.abs(camera.position.x - (blockX + 0.5));
                        const dz = Math.abs(camera.position.z - (blockZ + 0.5));
                        if (dx < PLAYER_RADIUS * 0.6 && dz < PLAYER_RADIUS * 0.6) {
                            canPlace = false;
                        }
                    }

                    if (canPlace) {
                        const type = currentSlot.type;
                        socket.emit('placeAttempt', { x: blockX, y: blockY, z: blockZ, type });
                    }
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                if (isBreaking && breakingBlock) {
                    const x = Math.floor(breakingBlock.position.x - 0.5);
                    const y = Math.floor(breakingBlock.position.y - 0.5);
                    const z = Math.floor(breakingBlock.position.z - 0.5);
                    
                    socket.emit('stopBreaking', { x, y, z });
                }
                
                isBreaking = false;
                breakingBlock = null;
                document.getElementById('break-progress').style.display = 'none';
                document.getElementById('break-progress-bar').style.width = '0%';
                if (breakingOverlay) {
                    scene.remove(breakingOverlay);
                    breakingOverlay = null;
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        function checkCollision(pos) {
            if (isSpectator) return false;
            
            const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
            const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(pos.x, pos.y - (currentEyeHeight - currentPlayerHeight/2), pos.z),
                new THREE.Vector3(PLAYER_RADIUS * 2, currentPlayerHeight - 0.1, PLAYER_RADIUS * 2)
            );
            for (const b of blocksInScene) {
                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(b))) return true;
            }
            return false;
        }

        function wouldFallOffEdge(pos, direction) {
            if (isSpectator) return false;
            if (!isCrouching || !onGround) return false;
            
            const checkDistance = -0.11;
            const checkPos = pos.clone().add(direction.multiplyScalar(checkDistance));
            checkPos.y -= EYE_HEIGHT + 0.2;
            const checkBox = new THREE.Box3().setFromCenterAndSize(
                checkPos,
                new THREE.Vector3(0.1, 0.1, 0.1)
            );
            for (const b of blocksInScene) {
                if (checkBox.intersectsBox(new THREE.Box3().setFromObject(b))) return false;
            }
            return true;
        }

        let prevTime = performance.now();
        let lastGeneratorUpdate = 0;
        let swordBobTime = 0;
        let lastBreakingProgressEmitted = 0;

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);
            prevTime = time;

            if (time - lastGeneratorUpdate > 100) {
                resourceSpawners.forEach(spawner => {
                    updateGeneratorText(spawner);
                });
                lastGeneratorUpdate = time;
            }
            
            cleanupOldBreakingOverlays();

            if (isBreaking && breakingBlock && !isSpectator) {
                if (!isStillLookingAtBlock()) {
                    if (breakingBlock) {
                        const x = Math.floor(breakingBlock.position.x - 0.5);
                        const y = Math.floor(breakingBlock.position.y - 0.5);
                        const z = Math.floor(breakingBlock.position.z - 0.5);
                        socket.emit('stopBreaking', { x, y, z });
                    }
                    
                    isBreaking = false;
                    breakingBlock = null;
                    document.getElementById('break-progress').style.display = 'none';
                    document.getElementById('break-progress-bar').style.width = '0%';
                    if (breakingOverlay) {
                        scene.remove(breakingOverlay);
                        breakingOverlay = null;
                    }
                } else {
                    const elapsed = Date.now() - breakingStartTime;
                    const progress = Math.min(elapsed / breakingDuration, 1);
                    document.getElementById('break-progress-bar').style.width = (progress * 100) + '%';

                    if (breakingOverlay && breakingTextures.length > 0) {
                        const textureIndex = Math.min(Math.floor(progress * 9), 8);
                        if (textureIndex >= 0 && textureIndex < breakingTextures.length) {
                            breakingOverlay.material.map = breakingTextures[textureIndex];
                            breakingOverlay.material.needsUpdate = true;
                        }
                    }
                    
                    if (time - lastBreakingProgressEmitted > 100) {
                        const x = Math.floor(breakingBlock.position.x - 0.5);
                        const y = Math.floor(breakingBlock.position.y - 0.5);
                        const z = Math.floor(breakingBlock.position.z - 0.5);
                        
                        socket.emit('breakingProgress', {
                            x, y, z,
                            progress: progress
                        });
                        lastBreakingProgressEmitted = time;
                    }

                    if (elapsed >= breakingDuration) {
                        const x = Math.floor(breakingBlock.position.x - 0.5);
                        const y = Math.floor(breakingBlock.position.y - 0.5);
                        const z = Math.floor(breakingBlock.position.z - 0.5);
                        socket.emit('breakAttempt', { x, y, z });
                        
                        socket.emit('stopBreaking', { x, y, z });
                        
                        isBreaking = false;
                        breakingBlock = null;
                        document.getElementById('break-progress').style.display = 'none';
                        document.getElementById('break-progress-bar').style.width = '0%';
                        if (breakingOverlay) {
                            scene.remove(breakingOverlay);
                            breakingOverlay = null;
                        }
                    }
                }
            }

            const now = Date.now();

            resourceSpawners.forEach(spawner => {
                const pulseSpeed = 2;
                const pulseAmount = 0.1;
                const scale = 1 + Math.sin(now / 200 * pulseSpeed) * pulseAmount;
                spawner.scale.set(scale, scale, scale);
            });

            for (let i = resourcePickups.length - 1; i >= 0; i--) {
                const pickup = resourcePickups[i];
                
                const floatOffset = Math.sin((now - pickup.userData.spawnTime) / 500) * 0.15;
                pickup.position.y = pickup.userData.baseY + floatOffset;
                
                pickup.lookAt(camera.position);

                const dist = camera.position.distanceTo(pickup.position);
                if (dist < 1.5 && !isSpectator) {
                    socket.emit('claimPickupAttempt', pickup.userData.id);
                    removePickupMesh(pickup.userData.id);
                }
            }

            projectiles.forEach((pearl, id) => {
                const userData = pearl.userData;
                if (!userData || !userData.velocity) return;
                
                const deltaTime = (now - userData.lastUpdate) / 1000;
                
                if (deltaTime > 0) {
                    userData.lastPos = {
                        x: pearl.position.x,
                        y: pearl.position.y,
                        z: pearl.position.z
                    };
                    
                    pearl.position.x += userData.velocity.x * deltaTime;
                    pearl.position.y += userData.velocity.y * deltaTime;
                    pearl.position.z += userData.velocity.z * deltaTime;
                    
                    const GRAVITY = 20;
                    userData.velocity.y -= GRAVITY * deltaTime;
                    
                    userData.lastUpdate = now;
                    
                    pearl.lookAt(camera.position);
                    
                    pearl.material.rotation += 0.1;
                    pearl.material.needsUpdate = true;
                    
                    const pulse = 0.1 * Math.sin(now / 200);
                    pearl.scale.set(0.5 + pulse, 0.5 + pulse, 1);
                }
            });

            fireballProjectiles.forEach((fireball, id) => {
                const userData = fireball.userData;
                if (!userData || !userData.velocity) return;
                
                const deltaTime = (now - userData.lastUpdate) / 1000;
                
                if (deltaTime > 0) {
                    const lastPos = {
                        x: fireball.position.x,
                        y: fireball.position.y,
                        z: fireball.position.z
                    };
                    
                    fireball.position.x += userData.velocity.x * deltaTime;
                    fireball.position.y += userData.velocity.y * deltaTime;
                    fireball.position.z += userData.velocity.z * deltaTime;
                    
                    const GRAVITY = 10;
                    userData.velocity.y -= GRAVITY * deltaTime;
                    
                    userData.lastUpdate = now;
                    
                    fireball.lookAt(camera.position);
                    
                    fireball.scale.set(0.8, 0.8, 1);
                    
                    fireball.material.opacity = 1.0;
                    fireball.material.needsUpdate = true;
                    
                    const currentPos = fireball.position.clone();
                    const direction = new THREE.Vector3().subVectors(currentPos, lastPos);
                    const distance = direction.length();
                    
                    if (distance > 0) {
                        direction.normalize();
                        
                        const tempRaycaster = new THREE.Raycaster();
                        tempRaycaster.set(lastPos, direction);
                        
                        const intersects = tempRaycaster.intersectObjects(blocksInScene);
                        
                        if (intersects.length > 0) {
                            const intersect = intersects[0];
                            if (intersect.distance <= distance) {
                                const hitBlock = intersect.object;
                                const blockX = Math.floor(hitBlock.position.x - 0.5);
                                const blockY = Math.floor(hitBlock.position.y - 0.5);
                                const blockZ = Math.floor(hitBlock.position.z - 0.5);
                                
                                socket.emit('fireballHitBlock', {
                                    fireballId: id,
                                    x: blockX,
                                    y: blockY,
                                    z: blockZ
                                });
                                
                                createFireballExplosion(blockX, blockY, blockZ);
                                
                                removeFireballMesh(id);
                            }
                        }
                    }
                }
            });

            if (!isSpectator) {
                velocity.y -= 20.0 * delta;

                const direction = new THREE.Vector3();
                direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                direction.x = Number(moveState.r) - Number(moveState.l);
                direction.normalize();

                const baseSpeed = 5.0;
                const speed = isCrouching ? baseSpeed * 0.6 : baseSpeed;

                if (controls.isLocked) {
                    if (direction.x !== 0) {
                        const moveDir = new THREE.Vector3(1, 0, 0);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.x))) {
                            controls.moveRight(direction.x * speed * delta);
                            if (checkCollision(camera.position)) controls.moveRight(-direction.x * speed * delta);
                        }
                    }

                    if (direction.z !== 0) {
                        const moveDir = new THREE.Vector3(0, 0, -1);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.z))) {
                            controls.moveForward(direction.z * speed * delta);
                            if (checkCollision(camera.position)) controls.moveForward(-direction.z * speed * delta);
                        }
                    }
                }
                
                camera.position.y += velocity.y * delta;
                onGround = false;

                const currentEyeHeightForFoot = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                const footBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(camera.position.x, camera.position.y - currentEyeHeightForFoot, camera.position.z),
                    new THREE.Vector3(PLAYER_RADIUS, 0.2, PLAYER_RADIUS)
                );

                for (const b of blocksInScene) {
                    const bBox = new THREE.Box3().setFromObject(b);
                    if (footBox.intersectsBox(bBox)) {
                        if (velocity.y < 0) {
                            velocity.y = 0;
                            camera.position.y = bBox.max.y + currentEyeHeightForFoot;
                            onGround = true;
                        }
                    }
                }

                if (camera.position.y < -30 && isInRound) {
                }
            } else if (controls.isLocked) {
                const direction = new THREE.Vector3();
                direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                direction.x = Number(moveState.r) - Number(moveState.l);
                direction.normalize();
                
                const speed = 10.0;
                
                if (direction.x !== 0) {
                    const moveDir = new THREE.Vector3(1, 0, 0);
                    moveDir.applyQuaternion(camera.quaternion);
                    moveDir.normalize();
                    controls.moveRight(direction.x * speed * delta);
                }

                if (direction.z !== 0) {
                    const moveDir = new THREE.Vector3(0, 0, -1);
                    moveDir.applyQuaternion(camera.quaternion);
                    moveDir.normalize();
                    controls.moveForward(direction.z * speed * delta);
                }
                
                camera.position.y += velocity.y * delta;
                velocity.y = 0;
                onGround = true;
            }

            if (!isSpectator && socket.connected && time - lastPlayerUpdate > 50) {
                const currentSlot = inventory[selectedSlotIndex];
                const equippedWeapon = currentSlot && currentSlot.type && BLOCK_TYPES[currentSlot.type] && BLOCK_TYPES[currentSlot.type].isWeapon ? currentSlot.type : null;
                
                socket.emit('playerUpdate', {
                    pos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    rot: { yaw: camera.rotation.y, pitch: camera.rotation.x },
                    crouch: isCrouching,
                    selected: selectedSlotIndex,
                    spectator: isSpectator,
                    equippedWeapon: equippedWeapon
                });
                lastPlayerUpdate = time;
            }

            otherPlayers.forEach((data, id) => {
                if (data.spectator) {
                    data.group.visible = false;
                    return;
                }
                
                data.group.visible = true;
                data.group.position.lerp(new THREE.Vector3(data.targetPos.x, data.targetPos.y, data.targetPos.z), 0.15);
                data.group.rotation.y = THREE.MathUtils.lerp(data.group.rotation.y || 0, data.targetRot.yaw, 0.15);
                data.head.rotation.x = THREE.MathUtils.lerp(data.head.rotation.x || 0, data.targetRot.pitch, 0.15);
                
                if (data.targetCrouch !== data.crouch) {
                    data.crouch = data.targetCrouch;
                }
                data.group.scale.y = data.crouch ? 0.75 : 1;
                
                if (data.healthBar && playerHealth.has(id)) {
                    const health = playerHealth.get(id);
                    data.healthBar.style.width = `${health * 10}%`;
                    data.healthBar.style.backgroundColor = health > 5 ? '#4CAF50' : health > 2 ? '#FFA500' : '#FF0000';
                }
                
                if (playerSwords.has(id)) {
                    const sword = playerSwords.get(id);
                    sword.lookAt(camera.position);
                    sword.rotation.z = Math.PI / 4;
                }
            });

            renderer.render(scene, camera);
        }

        let lastPlayerUpdate = 0;

        function addToInventory(blockType, amount) {
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                if (inventory[i] && inventory[i].type === blockType && inventory[i].count < MAX_STACK) {
                    const space = MAX_STACK - inventory[i].count;
                    const toAdd = Math.min(space, amount);
                    inventory[i].count += toAdd;
                    amount -= toAdd;
                    if (amount === 0) {
                        updateUI();
                        return true;
                    }
                }
            }
            if (amount > 0) {
                for (let i = 0; i < INVENTORY_SIZE; i++) {
                    if (inventory[i] === null) {
                        const toAdd = Math.min(MAX_STACK, amount);
                        inventory[i] = { type: blockType, count: toAdd };
                        amount -= toAdd;
                        if (amount === 0) {
                            updateUI();
                            return true;
                        }
                    }
                }
            }
            updateUI();
            return amount === 0;
        }

        function selectSlot(index) {
            if (isSpectator) return;
            
            selectedSlotIndex = index;
            updateUI();
            updateSwordInHand();
            
            const slot = inventory[selectedSlotIndex];
            const overlay = document.getElementById('item-name-overlay');
            if (slot) {
                overlay.innerText = slot.type;
                overlay.style.opacity = '1';
                overlay.style.color = '#' + (BLOCK_TYPES[slot.type]?.color?.toString(16).padStart(6, '0') || 'ffffff');
                if (overlayTimeout) clearTimeout(overlayTimeout);
                overlayTimeout = setTimeout(() => { overlay.style.opacity = '0'; }, 2000);
            } else {
                overlay.style.opacity = '0';
            }
        }

        const hotbarContainer = document.getElementById('hotbar-container');

        function updateUI() {
            document.getElementById('iron').innerText = currency.iron;
            document.getElementById('gold').innerText = currency.gold;
            document.getElementById('emerald').innerText = currency.emerald;

            hotbarContainer.innerHTML = '';
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                const slot = inventory[i];
                const div = document.createElement('div');
                div.className = `inv-slot ${i === selectedSlotIndex ? 'active' : ''}`;
                div.onclick = () => selectSlot(i);

                const keyHint = document.createElement('span');
                keyHint.className = 'slot-key';
                keyHint.innerText = i + 1;
                div.appendChild(keyHint);

                if (slot) {
                    const blockData = BLOCK_TYPES[slot.type];
                    if (blockData.hasTexture) {
                        const icon = document.createElement('img');
                        icon.className = 'block-icon';
                        if (slot.type === 'Grass') icon.src = TEXTURE_URLS.grass;
                        else if (slot.type === 'Wood') icon.src = TEXTURE_URLS.wood;
                        else if (slot.type === 'Stone') icon.src = TEXTURE_URLS.stone;
                        else if (slot.type === 'Obsidian') icon.src = TEXTURE_URLS.obsidian;
                        else if (slot.type === 'Enderpearl') icon.src = TEXTURE_URLS.enderpearl;
                        else if (slot.type === 'Fireball') icon.src = TEXTURE_URLS.fireball;
                        else if (slot.type === 'Wooden Sword') icon.src = TEXTURE_URLS.woodenSword;
                        else if (slot.type === 'Iron Sword') icon.src = TEXTURE_URLS.ironSword;
                        else if (slot.type === 'Emerald Sword') icon.src = TEXTURE_URLS.emeraldSword;
                        div.appendChild(icon);
                    } else {
                        const icon = document.createElement('div');
                        icon.className = 'block-icon';
                        icon.style.backgroundColor = '#' + blockData.color.toString(16).padStart(6, '0');
                        if(blockData.opacity) icon.style.opacity = blockData.opacity;
                        div.appendChild(icon);
                    }

                    const count = document.createElement('span');
                    count.className = 'slot-count';
                    count.innerText = slot.count;
                    div.appendChild(count);
                }

                hotbarContainer.appendChild(div);
            }
        }

        function canAfford(cost) {
            for (let [resource, amount] of Object.entries(cost)) {
                if (currency[resource] < amount) return false;
            }
            return true;
        }

        function renderShop() {
            const container = document.getElementById('shop-container');
            container.innerHTML = '';
            Object.entries(BLOCK_TYPES).filter(([name]) => name !== 'Bed').forEach(([name, data]) => {
                const item = document.createElement('div');
                const affordable = canAfford(data.cost);
                item.className = `shop-item ${affordable ? '' : 'disabled'}`;
                
                let imageUrl = '';
                if (name === 'Grass') imageUrl = TEXTURE_URLS.grass;
                else if (name === 'Wood') imageUrl = TEXTURE_URLS.wood;
                else if (name === 'Stone') imageUrl = TEXTURE_URLS.stone;
                else if (name === 'Obsidian') imageUrl = TEXTURE_URLS.obsidian;
                else if (name === 'Glass') imageUrl = '';
                else if (name === 'Enderpearl') imageUrl = TEXTURE_URLS.enderpearl;
                else if (name === 'Fireball') imageUrl = TEXTURE_URLS.fireball;
                else if (name === 'Wooden Sword') imageUrl = TEXTURE_URLS.woodenSword;
                else if (name === 'Iron Sword') imageUrl = TEXTURE_URLS.ironSword;
                else if (name === 'Emerald Sword') imageUrl = TEXTURE_URLS.emeraldSword;
                
                const costText = Object.entries(data.cost)
                    .map(([res, amt]) => `${amt} ${res}`)
                    .join(' + ');
                
                item.innerHTML = `
                    ${imageUrl ? `<img src="${imageUrl}" class="shop-icon" alt="${name}">` : 
                    `<div class="shop-icon" style="background:#${data.color.toString(16).padStart(6,'0')}; ${data.opacity ? `opacity:${data.opacity};` : ''}"></div>`}
                    <strong>${name}</strong><br>
                    <span style="font-size:0.9em; color:#aaa;">${data.buyAmount}x</span><br>
                    <span style="color: ${affordable ? '#4d9043' : '#d32f2f'}">${costText}</span>
                    ${data.isWeapon ? `<br><span style="color:#ff8888; font-size:0.8em;">Damage: ${data.damage}</span>` : ''}
                `;
                item.onclick = () => {
                    wasBuying = true;
                    socket.emit('buyAttempt', name);
                };
                container.appendChild(item);
            });
        }

        function toggleShop() {
            if (isSpectator) return;
            
            const shop = document.getElementById('shop');
            const isVisible = shop.style.display === 'block';
            
            if (isVisible) {
                shop.style.display = 'none';
                controls.lock();
            } else {
                shop.style.display = 'block';
                controls.unlock();
                renderShop();
            }
        }

        function getPlayerColor(id) {
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            hash = Math.abs(hash) % 360;
            const color = new THREE.Color().setHSL(hash / 360, 0.7, 0.6);
            return color;
        }

        function createOtherPlayer(id, health = 10, equippedWeapon = null) {
            const group = new THREE.Group();
            group.name = id;

            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.4;
            group.add(head);

            const bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyColor = getPlayerColor(id);
            const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.7;
            group.add(body);

            const armGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
            const armMat = bodyMat;
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(0.5, 0.7, 0);
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(-0.5, 0.7, 0);
            group.add(rightArm);

            const legGeo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x333366 });
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(0.2, 0, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(-0.2, 0, 0);
            group.add(rightLeg);

            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(id.substring(0, 6).toUpperCase(), 128, 25);
            ctx.fillStyle = '#4CAF50';
            ctx.font = '18px Arial';
            ctx.fillText(` ${health}/10`, 128, 50);
            const texture = new THREE.CanvasTexture(canvas);
            const nameMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.4),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide })
            );
            nameMesh.position.y = 2.2;
            nameMesh.name = 'nameTag';
            group.add(nameMesh);

            scene.add(group);

            otherPlayers.set(id, {
                group,
                head,
                targetPos: { x: 0, y: 0, z: 0 },
                targetRot: { yaw: 0, pitch: 0 },
                targetCrouch: false,
                crouch: false,
                spectator: false,
                healthBar: null,
                equippedWeapon: equippedWeapon
            });

            playerHealth.set(id, health);
            
            if (equippedWeapon) {
                updateOtherPlayerSword(id, equippedWeapon);
            }
            
            return group;
        }

        function updatePlayerHealth(id, health) {
            playerHealth.set(id, health);
            
            const op = otherPlayers.get(id);
            if (!op || !op.group) return;
            
            const nameTag = op.group.children.find(child => child.name === 'nameTag');
            if (nameTag && nameTag.material.map) {
                const canvas = nameTag.material.map.image;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(id.substring(0, 6).toUpperCase(), 128, 25);
                
                let healthColor = '#4CAF50';
                if (health <= 5) healthColor = '#FFA500';
                if (health <= 2) healthColor = '#FF0000';
                
                ctx.fillStyle = healthColor;
                ctx.font = '18px Arial';
                ctx.fillText(` ${health}/10`, 128, 50);
                
                nameTag.material.map.needsUpdate = true;
            }
        }

        function removeOtherPlayer(id) {
            const op = otherPlayers.get(id);
            if (op) {
                scene.remove(op.group);
                otherPlayers.delete(id);
                playerHealth.delete(id);
                if (playerSwords.has(id)) {
                    playerSwords.delete(id);
                }
            }
        }

        function showNotification(msg, duration = 3000) {
            const el = document.getElementById('notification');
            el.innerText = msg;
            el.style.display = 'block';
            setTimeout(() => {
                el.style.display = 'none';
            }, duration);
        }

        // Socket events
        socket.on('yourId', (id) => {
            playerId = id;
            setSpectatorMode(true);
        });

        socket.on('initWorld', ({ blocks, pickups, spawners: initSpawners, gameActive, playersNeeded }) => {
            blocks.forEach(({ x, y, z, type }) => addBlockMesh(x, y, z, type));
            pickups.forEach(addPickupMesh);
            initSpawners.forEach(s => {
                const spawnerMesh = addResourceSpawner(s.x, s.y, s.z, s.resourceType, s.interval, s.lastSpawn);
                if (s.lastSpawn) {
                    spawnerMesh.userData.lastSpawn = s.lastSpawn;
                }
            });
            
            isInRound = gameActive;
            updateWaitingMessage(playersNeeded);
        });

        socket.on('playersSnapshot', (others) => {
            others.forEach(({ id, pos, rot, crouch, spectator, health, equippedWeapon }) => {
                if (spectator) return;
                createOtherPlayer(id, health || 10, equippedWeapon);
                const op = otherPlayers.get(id);
                
                // FIX: Convert eye position to feet position by subtracting eye height
                const eyeHeight = crouch ? CROUCH_HEIGHT : EYE_HEIGHT;
                op.targetPos = {
                    x: pos.x,
                    y: pos.y - eyeHeight, // Subtract eye height to get feet position
                    z: pos.z
                };
                op.targetRot = rot;
                op.targetCrouch = crouch;
                op.spectator = spectator;
                op.equippedWeapon = equippedWeapon;
            });
        });

        socket.on('newPlayer', ({ id, pos, rot, crouch, spectator, health, equippedWeapon }) => {
            if (spectator) return;
            createOtherPlayer(id, health || 10, equippedWeapon);
            const op = otherPlayers.get(id);
            
            // FIX: Convert eye position to feet position by subtracting eye height
            const eyeHeight = crouch ? CROUCH_HEIGHT : EYE_HEIGHT;
            op.targetPos = {
                x: pos.x,
                y: pos.y - eyeHeight, // Subtract eye height to get feet position
                z: pos.z
            };
            op.targetRot = rot;
            op.targetCrouch = crouch;
            op.spectator = spectator;
            op.equippedWeapon = equippedWeapon;
        });

        socket.on('playersUpdate', (states) => {
            states.forEach(({ id, pos, rot, crouch, spectator, health, equippedWeapon }) => {
                if (id === playerId) return;
                let op = otherPlayers.get(id);
                if (!op && !spectator) {
                    createOtherPlayer(id, health || 10, equippedWeapon);
                    op = otherPlayers.get(id);
                }
                if (op) {
                    // FIX: Convert eye position to feet position by subtracting eye height
                    const eyeHeight = crouch ? CROUCH_HEIGHT : EYE_HEIGHT;
                    op.targetPos = {
                        x: pos.x,
                        y: pos.y - eyeHeight, // Subtract eye height to get feet position
                        z: pos.z
                    };
                    op.targetRot = rot;
                    op.targetCrouch = crouch;
                    op.spectator = spectator;
                    
                    if (equippedWeapon !== op.equippedWeapon) {
                        op.equippedWeapon = equippedWeapon;
                        updateOtherPlayerSword(id, equippedWeapon);
                    }
                    
                    if (spectator) {
                        op.group.visible = false;
                        if (playerSwords.has(id)) {
                            const sword = playerSwords.get(id);
                            op.group.remove(sword);
                            playerSwords.delete(id);
                        }
                    } else {
                        op.group.visible = true;
                    }
                }
            });
        });

        socket.on('addBlock', ({ x, y, z, type }) => addBlockMesh(x, y, z, type));
        socket.on('removeBlock', ({ x, y, z }) => removeBlockMesh(x, y, z));
        socket.on('addPickup', addPickupMesh);
        socket.on('removePickup', (id) => removePickupMesh(id));

        socket.on('revertBreak', ({ x, y, z, type }) => {
            if (type) addBlockMesh(x, y, z, type);
            else removeBlockMesh(x, y, z);
        });
        
        socket.on('revertPlace', ({ x, y, z }) => removeBlockMesh(x, y, z));
        socket.on('revertPickup', addPickupMesh);

        socket.on('updateCurrency', (curr) => {
            currency = curr;
            updateUI();
        });
        
        socket.on('updateInventory', (inv) => {
            inventory = inv;
            updateUI();
            updateSwordInHand();
            wasBuying = false;
        });
        
        socket.on('buyFailed', () => {
            showNotification('Not enough resources or inventory full!');
            renderShop();
            wasBuying = false;
        });

        // Enderpearl events
        socket.on('addEnderpearl', (data) => {
            createEnderpearlMesh(data);
        });

        socket.on('updateEnderpearl', (data) => {
            if (Array.isArray(data)) {
                data.forEach(pearl => updateEnderpearl(pearl));
            } else {
                updateEnderpearl(data);
            }
        });

        socket.on('removeEnderpearl', (id) => {
            removeEnderpearlMesh(id);
        });

        // Fireball events
        socket.on('addFireball', (data) => {
            createFireballMesh(data);
        });

        socket.on('updateFireball', (data) => {
            if (Array.isArray(data)) {
                data.forEach(fireball => updateFireballMesh(fireball));
            } else {
                updateFireballMesh(data);
            }
        });

        socket.on('removeFireball', (id) => {
            removeFireballMesh(id);
        });

        socket.on('fireballExplosion', ({ x, y, z, blocksDestroyed }) => {
            createFireballExplosion(x, y, z);
            
            if (blocksDestroyed) {
                blocksDestroyed.forEach(({ x, y, z }) => {
                    removeBlockMesh(x, y, z);
                });
            }
        });

        // Breaking animation events for other players
        socket.on('startBreaking', ({ x, y, z, playerId, breakTime }) => {
            if (playerId === socket.id) return;
            
            createOtherPlayerBreakingOverlay(x, y, z, 0);
        });

        socket.on('breakingProgress', ({ x, y, z, playerId, progress }) => {
            if (playerId === socket.id) return;
            
            updateOtherPlayerBreakingOverlay(x, y, z, progress);
        });

        socket.on('stopBreaking', ({ x, y, z, playerId }) => {
            if (playerId === socket.id) return;
            
            removeOtherPlayerBreakingOverlay(x, y, z);
        });

        socket.on('removePlayer', (id) => {
            removeOtherPlayer(id);
        });

        socket.on('respawn', (data) => {
            camera.position.set(data.pos.x, data.pos.y, data.pos.z);
            camera.rotation.set(data.rot.pitch, data.rot.yaw, 0);
            velocity.set(0, 0, 0);
        });

        socket.on('teleport', (data) => {
            camera.position.set(data.x, data.y, data.z);
            velocity.set(0, 0, 0);
            showNotification('Teleported!', 1500);
        });

        socket.on('bedDestroyed', () => {
            showNotification('Your bed was destroyed! You will not respawn!', 5000);
        });

        socket.on('notification', (msg) => {
            showNotification(msg);
        });

        socket.on('countdown', (sec) => {
            showNotification(`Starting in ${sec}`, 1100);
            updateWaitingMessage(0);
        });

        socket.on('gameStart', () => {
            showNotification('GO!');
            isInRound = true;
            startRoundTimer(900);
        });

        socket.on('assignBed', (data) => {
            showNotification(`Assigned to Iron Island!`, 3000);
            setSpectatorMode(false);
            
            camera.position.set(data.pos.x, data.pos.y, data.pos.z);
            camera.rotation.set(data.rot.pitch, data.rot.yaw, 0);
            velocity.set(0, 0, 0);
            
            inventory = data.inventory;
            currency = data.currency;
            updateUI();
            updateSwordInHand();
        });

        socket.on('gameEnd', ({ winner }) => {
            if (winner === playerId) {
                showNotification('You Win!', 5000);
            } else if (winner) {
                showNotification(`Player ${winner.substring(0,6)} Wins!`, 5000);
            } else {
                showNotification('Game ended with no winner!', 5000);
            }
            isInRound = false;
            stopRoundTimer();
            setSpectatorMode(true);
        });

        socket.on('worldReset', (data) => {
            blocksInScene.forEach((m) => {
                scene.remove(m);
            });
            blocksInScene.length = 0;
            blocksMeshes.clear();
            
            resourcePickups.forEach((m) => {
                scene.remove(m);
            });
            resourcePickups.length = 0;
            pickupMeshes.clear();
            
            resourceSpawners.forEach((spawner) => {
                scene.remove(spawner);
                if (spawner.userData.textSprite) {
                    scene.remove(spawner.userData.textSprite);
                }
            });
            resourceSpawners.length = 0;
            
            projectiles.forEach((pearl, id) => {
                removeEnderpearlMesh(id);
            });
            projectiles.clear();
            
            fireballProjectiles.forEach((fireball, id) => {
                removeFireballMesh(id);
            });
            fireballProjectiles.clear();
            
            otherPlayers.forEach((op, id) => {
                scene.remove(op.group);
            });
            otherPlayers.clear();
            playerHealth.clear();
            playerSwords.clear();
            
            breakingOverlays.forEach((data, key) => {
                scene.remove(data.mesh);
            });
            breakingOverlays.clear();
            
            if (swordInHand) {
                scene.remove(swordInHand);
                swordInHand = null;
            }
            
            data.blocks.forEach(({ x, y, z, type }) => {
                addBlockMesh(x, y, z, type);
            });
            
            data.pickups.forEach(addPickupMesh);
            
            data.spawners.forEach((s) => {
                const spawnerMesh = addResourceSpawner(s.x, s.y, s.z, s.resourceType, s.interval, s.lastSpawn);
                if (s.lastSpawn) {
                    spawnerMesh.userData.lastSpawn = s.lastSpawn;
                }
            });
            
            setSpectatorMode(true);
            showNotification('Game reset! Waiting for players...', 3000);
        });

        socket.on('playerReset', (data) => {
            camera.position.set(data.pos.x, data.pos.y, data.pos.z);
            camera.rotation.set(data.rot.pitch, data.rot.yaw, 0);
            inventory = data.inventory;
            currency = data.currency;
            updateUI();
            updateSwordInHand();
            velocity.set(0, 0, 0);
        });

        socket.on('setSpectator', (spectator) => {
            setSpectatorMode(spectator);
        });

        socket.on('updateWaiting', (playersNeeded) => {
            updateWaitingMessage(playersNeeded);
        });

        socket.on('updateTimer', (timeRemaining) => {
            roundTimeRemaining = timeRemaining;
            updateTimerDisplay(timeRemaining);
            if (timeRemaining > 0) {
                document.getElementById('timer').style.display = 'block';
            } else {
                document.getElementById('timer').style.display = 'none';
            }
        });

        // Player combat events
        socket.on('playerHit', ({ attackerId, targetId, newHealth }) => {
            updatePlayerHealth(targetId, newHealth);
            
            if (targetId === playerId && attackerId) {
                showNotification(`You were hit! Health: ${newHealth}/10`, 2000);
            }
        });

        socket.on('playerEliminated', ({ eliminatedId, eliminatorId }) => {
            if (eliminatedId === playerId) {
                showNotification('You were eliminated!', 3000);
            } else if (eliminatorId === playerId) {
                showNotification(`You eliminated ${eliminatedId.substring(0,6)}!`, 3000);
            } else {
                showNotification(`${eliminatedId.substring(0,6)} was eliminated!`, 3000);
            }
            
            removeOtherPlayer(eliminatedId);
        });

        // Start
        setSpectatorMode(true);
        updateUI();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
