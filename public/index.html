<!-- index.html (Updated with Chat and Spectator Mode) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Island Builder - Multiplayer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* Centered Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 10;
        }

        /* Top Left Stats */
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
        }

        .currency-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 1.2em;
            font-weight: bold;
        }

        .currency-icon {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            image-rendering: pixelated;
        }

        /* NEW: Spectator Indicator */
        #spectator-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff9900;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            display: none;
            z-index: 15;
        }

        /* Item Name Overlay (Minecraft Style) */
        #item-name-overlay {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            text-shadow: 0px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            z-index: 15;
        }

        /* Breaking Progress Bar */
        #break-progress {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 20px);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid white;
            border-radius: 4px;
            display: none;
            overflow: hidden;
        }

        #break-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4d9043, #7bc96f);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Inventory Hotbar */
        #hotbar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .inv-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #444;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
        }

        .inv-slot.active {
            border-color: white;
            transform: scale(1.1);
            background: rgba(50, 50, 50, 0.8);
        }

        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
        }

        .slot-key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #aaa;
        }

        /* Shop UI */
        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(16, 16, 16, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            display: none;
            text-align: center;
            border: 2px solid #555;
            min-width: 450px;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .shop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
        }

        .shop-item {
            padding: 15px;
            border: 1px solid #444;
            cursor: pointer;
            background: #222;
            transition: 0.2s;
        }

        .shop-item:hover {
            background: #333;
            border-color: #fff;
        }

        .shop-item:active {
            background: #444;
        }

        .shop-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .block-icon {
            width: 20px;
            height: 20px;
            border: 1px solid rgba(255,255,255,0.3);
            image-rendering: pixelated;
        }

        #controls-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ccc;
            font-size: 12px;
            text-align: right;
            text-shadow: 1px 1px 2px black;
        }

        .crouch-indicator {
            color: #ffff88 !important;
        }

        /* NEW: Chat System */
        #chat-container {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 300px;
            max-height: 200px;
            color: white;
            pointer-events: none;
        }

        #chat-messages {
            overflow-y: auto;
            max-height: 150px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 8px;
            margin-bottom: 5px;
            font-size: 12px;
            pointer-events: auto;
        }

        .chat-message {
            margin-bottom: 4px;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .chat-message.system {
            color: #aaa;
            font-style: italic;
        }

        .chat-message.player {
            color: #fff;
        }

        .chat-sender {
            font-weight: bold;
            margin-right: 5px;
        }

        .chat-sender.spectator {
            color: #ff9900;
        }

        #chat-input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            font-family: 'Segoe UI', sans-serif;
            pointer-events: auto;
        }

        #chat-input:focus {
            outline: none;
            border-color: #888;
        }

        /* Loading Screen for Cold Starts */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 100;
        }

        #notification {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 30px;
            text-shadow: 2px 2px 4px black;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            display: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="loading">Connecting to server...</div>
    <div id="crosshair"></div>
    <div id="spectator-indicator">SPECTATOR MODE (FLYING)</div>
    <div id="stats">
        <div class="currency-row">
            <img src="https://i.ibb.co/n87Ym7RY/pixilart-drawing-7.png" class="currency-icon">
            <span id="iron">0</span>
        </div>
        <div class="currency-row">
            <img src="https://i.ibb.co/27GwzjkT/pixilart-drawing-6.png" class="currency-icon">
            <span id="gold">0</span>
        </div>
        <div class="currency-row">
            <img src="https://i.ibb.co/hxX4ywxj/pixilart-drawing-8.png" class="currency-icon">
            <span id="emerald">0</span>
        </div>
    </div>
    <div id="controls-hint">
        WASD: Move | SPACE: Jump<br>
        <span id="crouch-hint">SHIFT: Crouch</span> | 1-9: Select<br>
        B: Shop | P: Toggle Spectator<br>
        T: Chat | ESC: Close Chat<br>
        <span style="color: #ff8888">Hold L-Click: Break</span><br>
        <span style="color: #88ff88">R-Click: Build</span>
    </div>
    <div id="break-progress">
        <div id="break-progress-bar"></div>
    </div>
    <div id="item-name-overlay"></div>
    
    <!-- NEW: Chat Container -->
    <div id="chat-container">
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" placeholder="Type your message... (Press Enter to send, ESC to cancel)" />
    </div>
    
    <div id="hotbar-container"></div>
    <div id="shop">
        <h2>Construction Shop</h2>
        <div style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">Click to buy blocks</div>
        <div class="shop-grid" id="shop-container"></div>
        <p style="color: #888; margin-top: 20px; font-size: 0.8em;">Press [B] to Close</p>
    </div>
    <div id="notification"></div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const socket = io({ reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 1000 });

        // --- NEW: Chat state ---
        let isChatting = false;
        let playerName = "Player";
        let isSpectator = false;
        let spectatorFlySpeed = 10.0;

        // --- Config ---
        const BLOCK_TYPES = {
            'Grass': { color: 0x4d9043, cost: { iron: 5 }, breakTime: 1.2, buyAmount: 8, hasTexture: true },
            'Glass': { color: 0xade8f4, cost: { iron: 5 }, breakTime: 0.4, buyAmount: 16, opacity: 0.6 },
            'Wood': { color: 0x5d4037, cost: { gold: 5 }, breakTime: 3, buyAmount: 32, hasTexture: true },
            'Stone': { color: 0x777777, cost: { gold: 5 }, breakTime: 6, buyAmount: 8, hasTexture: true },
            'Obsidian': { color: 0x111111, cost: { emerald: 1 }, breakTime: 12, buyAmount: 1, hasTexture: true },
            'Bed': { color: 0xff0000, breakTime: 2, buyAmount: 1, hasTexture: false }
        };
        const MAX_STACK = 64;
        const INVENTORY_SIZE = 9;
        const ISLAND_GAP = 18;

        // --- State ---
        let currency = { iron: 0, gold: 0, emerald: 0 };
        let inventory = new Array(INVENTORY_SIZE).fill(null);
        let selectedSlotIndex = 0;
        let overlayTimeout;

        const blocksInScene = [];
        const resourceSpawners = [];
        const resourcePickups = [];

        // Breaking state
        let isBreaking = false;
        let breakingBlock = null;
        let breakingStartTime = 0;
        let breakingDuration = 0;
        let breakingOverlay = null;

        // Crouching state
        let isCrouching = false;

        let playerId = null;
        let blocksMeshes = new Map();  // key -> mesh
        let pickupMeshes = new Map();  // id -> mesh
        let otherPlayers = new Map();  // id -> {group, head, targetPos, targetRot, name, spectator}

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6eb1ff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(20, 50, 20);
        scene.add(sun);

        // --- NEW: Chat Functions ---
        function showChatInput() {
            if (isChatting) return;
            isChatting = true;
            const chatInput = document.getElementById('chat-input');
            chatInput.style.display = 'block';
            chatInput.focus();
            controls.unlock();
            document.getElementById('controls-hint').style.opacity = '0.3';
        }

        function hideChatInput() {
            isChatting = false;
            const chatInput = document.getElementById('chat-input');
            chatInput.style.display = 'none';
            chatInput.value = '';
            if (!isSpectator) {
                controls.lock();
            }
            document.getElementById('controls-hint').style.opacity = '1';
        }

        function addChatMessage(sender, message, type = 'player', isSpectatorSender = false) {
            const chatMessages = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            
            if (type === 'system') {
                messageDiv.innerHTML = `<span class="chat-sender">${sender}</span> ${message}`;
            } else {
                const spectatorClass = isSpectatorSender ? 'spectator' : '';
                messageDiv.innerHTML = `<span class="chat-sender ${spectatorClass}">${sender}:</span> ${message}`;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Auto-hide after 10 seconds if not hovering
            setTimeout(() => {
                if (!chatMessages.matches(':hover')) {
                    chatMessages.style.opacity = '0.3';
                }
            }, 10000);
        }

        function toggleSpectatorMode() {
            socket.emit('toggleSpectator');
        }

        // --- Spectator Functions ---
        function setSpectatorMode(spectator) {
            isSpectator = spectator;
            const indicator = document.getElementById('spectator-indicator');
            const controlsHint = document.getElementById('controls-hint');
            
            if (isSpectator) {
                indicator.style.display = 'block';
                velocity.y = 0;
                onGround = false;
                // Update controls hint for spectators
                controlsHint.innerHTML = `
                    WASD: Move | SPACE/Q: Fly Up | SHIFT/E: Fly Down<br>
                    P: Toggle Spectator | T: Chat | ESC: Close Chat<br>
                    <span style="color: #ff9900">SPECTATOR MODE (No interaction)</span>
                `;
                // Unlock controls for spectators
                controls.unlock();
            } else {
                indicator.style.display = 'none';
                // Reset controls hint
                controlsHint.innerHTML = `
                    WASD: Move | SPACE: Jump<br>
                    <span id="crouch-hint">SHIFT: Crouch</span> | 1-9: Select<br>
                    B: Shop | P: Toggle Spectator<br>
                    T: Chat | ESC: Close Chat<br>
                    <span style="color: #ff8888">Hold L-Click: Break</span><br>
                    <span style="color: #88ff88">R-Click: Build</span>
                `;
            }
        }

        // --- Event Listeners (Updated) ---
        document.addEventListener('keydown', (e) => {
            // Chat input takes priority
            if (isChatting) {
                if (e.code === 'Escape') {
                    hideChatInput();
                }
                return;
            }

            // Spectator toggle
            if (e.code === 'KeyP') {
                toggleSpectatorMode();
                return;
            }

            // Chat activation
            if (e.code === 'KeyT') {
                e.preventDefault();
                showChatInput();
                return;
            }

            // Shop toggle
            if(e.code === 'KeyB') {
                if (!isSpectator) toggleShop();
                return;
            }

            if(document.getElementById('shop').style.display === 'block') return;

            // Slot selection
            if (e.code.startsWith('Digit') && e.code !== 'Digit0') {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 9) {
                    selectSlot(num - 1);
                }
            }

            // Movement keys
            switch(e.code) {
                case 'KeyW': moveState.fwd = true; break;
                case 'KeyS': moveState.bwd = true; break;
                case 'KeyA': moveState.l = true; break;
                case 'KeyD': moveState.r = true; break;
                case 'Space':
                    if (isSpectator) {
                        // Spectator fly up
                        moveState.up = true;
                    } else if(onGround && !isCrouching) {
                        velocity.y = 7.5;
                        onGround = false;
                    } else if (onGround && isCrouching) {
                        velocity.y = 6.;
                        onGround = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    e.preventDefault();
                    if (isSpectator) {
                        // Spectator fly down
                        moveState.down = true;
                    } else if (!isCrouching) {
                        isCrouching = true;
                        document.getElementById('crouch-hint').classList.add('crouch-indicator');
                    }
                    break;
                case 'KeyQ':
                    if (isSpectator) {
                        moveState.up = true;
                    }
                    break;
                case 'KeyE':
                    if (isSpectator) {
                        moveState.down = true;
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.fwd = false; break;
                case 'KeyS': moveState.bwd = false; break;
                case 'KeyA': moveState.l = false; break;
                case 'KeyD': moveState.r = false; break;
                case 'Space':
                    if (isSpectator) moveState.up = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    if (isSpectator) {
                        moveState.down = false;
                    } else {
                        isCrouching = false;
                        document.getElementById('crouch-hint').classList.remove('crouch-indicator');
                    }
                    break;
                case 'KeyQ':
                    if (isSpectator) moveState.up = false;
                    break;
                case 'KeyE':
                    if (isSpectator) moveState.down = false;
                    break;
            }
        });

        // Chat input event listener
        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                const message = chatInput.value.trim();
                if (message) {
                    socket.emit('chatMessage', message);
                }
                hideChatInput();
            } else if (e.code === 'Escape') {
                hideChatInput();
            }
        });

        // Keep hover functionality for chat
        const chatMessagesDiv = document.getElementById('chat-messages');
        chatMessagesDiv.addEventListener('mouseenter', () => {
            chatMessagesDiv.style.opacity = '1';
        });

        chatMessagesDiv.addEventListener('mouseleave', () => {
            setTimeout(() => {
                if (!chatMessagesDiv.matches(':hover')) {
                    chatMessagesDiv.style.opacity = '0.3';
                }
            }, 2000);
        });

        // --- Movement State (Updated for Spectator) ---
        const moveState = { 
            fwd: false, 
            bwd: false, 
            l: false, 
            r: false,
            up: false,    // Spectator fly up
            down: false   // Spectator fly down
        };

        // --- Physics & Controls ---
        const PLAYER_HEIGHT = 1.8;
        const EYE_HEIGHT = 1.6;
        const CROUCH_HEIGHT = 1.3;
        const PLAYER_RADIUS = 0.4;

        camera.position.set(-12, 5, -12);
        const controls = new PointerLockControls(camera, document.body);
        const velocity = new THREE.Vector3();
        let onGround = false;

        const raycaster = new THREE.Raycaster();

        // Mouse event handlers (with spectator check)
        document.addEventListener('mousedown', (e) => {
            if (isChatting) return;
            
            if (!controls.isLocked && !isSpectator) {
                if(document.getElementById('shop').style.display !== 'block') controls.lock();
                return;
            }

            // Don't allow interaction in spectator mode
            if (isSpectator) return;

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(blocksInScene);

            if (e.button === 2) { // Build
                const currentSlot = inventory[selectedSlotIndex];
                if (intersects.length > 0 && currentSlot && currentSlot.count > 0) {
                    const intersect = intersects[0];
                    if (intersect.distance > 5) return;
                    const pos = intersect.point.clone().add(intersect.face.normal.multiplyScalar(0.5));

                    const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                    const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;

                    const blockX = Math.floor(pos.x);
                    const blockY = Math.floor(pos.y);
                    const blockZ = Math.floor(pos.z);

                    let canPlace = true;
                    const playerFeetY = camera.position.y - currentEyeHeight;
                    const playerHeadY = camera.position.y - currentEyeHeight + currentPlayerHeight;
                    const blockMinY = blockY;
                    const blockMaxY = blockY + 1;
                    if (blockMaxY > playerFeetY && blockMinY < playerHeadY) {
                        const dx = Math.abs(camera.position.x - (blockX + 0.5));
                        const dz = Math.abs(camera.position.z - (blockZ + 0.5));
                        if (dx < PLAYER_RADIUS * 0.6 && dz < PLAYER_RADIUS * 0.6) {
                            canPlace = false;
                        }
                    }

                    if (canPlace) {
                        const type = currentSlot.type;
                        socket.emit('placeAttempt', { x: blockX, y: blockY, z: blockZ, type });
                    }
                }
            } else if (e.button === 0) { // Break
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (intersects[0].distance > 5) return;
                    if (obj.userData.type !== 'spawner') {
                        const type = obj.userData.type || 'Grass';
                        isBreaking = true;
                        breakingBlock = obj;
                        breakingStartTime = Date.now();
                        breakingDuration = BLOCK_TYPES[type].breakTime * 1000;
                        document.getElementById('break-progress').style.display = 'block';
                        
                        if (!breakingOverlay && breakingTextures.length > 0) {
                            const overlayMaterial = new THREE.MeshBasicMaterial({
                                map: breakingTextures[0],
                                transparent: true,
                                opacity: 0.8,
                                depthWrite: false
                            });
                            breakingOverlay = new THREE.Mesh(
                                new THREE.BoxGeometry(1.01, 1.01, 1.01),
                                overlayMaterial
                            );
                            breakingOverlay.position.copy(obj.position);
                            scene.add(breakingOverlay);
                        }
                    }
                }
            }
        });

        // ... (rest of the original mouse event handlers remain the same)

        // Collision check (skip for spectators)
        function checkCollision(pos) {
            if (isSpectator) return false;
            
            const currentEyeHeight = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
            const currentPlayerHeight = isCrouching ? (PLAYER_HEIGHT - 0.5) : PLAYER_HEIGHT;
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(pos.x, pos.y - (currentEyeHeight - currentPlayerHeight/2), pos.z),
                new THREE.Vector3(PLAYER_RADIUS * 2, currentPlayerHeight - 0.1, PLAYER_RADIUS * 2)
            );
            for (const b of blocksInScene) {
                if (playerBox.intersectsBox(new THREE.Box3().setFromObject(b))) return true;
            }
            return false;
        }

        function wouldFallOffEdge(pos, direction) {
            if (isSpectator) return false;
            if (!isCrouching || !onGround) return false;
            const checkDistance = -0.11;
            const checkPos = pos.clone().add(direction.multiplyScalar(checkDistance));
            checkPos.y -= EYE_HEIGHT + 0.2;
            const checkBox = new THREE.Box3().setFromCenterAndSize(
                checkPos,
                new THREE.Vector3(0.1, 0.1, 0.1)
            );
            for (const b of blocksInScene) {
                if (checkBox.intersectsBox(new THREE.Box3().setFromObject(b))) return false;
            }
            return true;
        }

        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);
            prevTime = time;

            // Movement and physics (spectator vs player)
            if (controls.isLocked || isSpectator) {
                if (isSpectator) {
                    // Spectator flying movement
                    velocity.y = 0;
                    
                    const direction = new THREE.Vector3();
                    direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                    direction.x = Number(moveState.r) - Number(moveState.l);
                    direction.y = Number(moveState.up) - Number(moveState.down);
                    direction.normalize();
                    
                    const speed = spectatorFlySpeed;
                    
                    if (direction.x !== 0) {
                        const moveDir = new THREE.Vector3(1, 0, 0);
                        moveDir.applyQuaternion(camera.quaternion);
                        controls.moveRight(direction.x * speed * delta);
                    }

                    if (direction.z !== 0) {
                        const moveDir = new THREE.Vector3(0, 0, -1);
                        moveDir.applyQuaternion(camera.quaternion);
                        controls.moveForward(direction.z * speed * delta);
                    }

                    if (direction.y !== 0) {
                        camera.position.y += direction.y * speed * delta;
                    }
                    
                } else {
                    // Normal player movement (original code)
                    velocity.y -= 20.0 * delta;

                    const direction = new THREE.Vector3();
                    direction.z = Number(moveState.fwd) - Number(moveState.bwd);
                    direction.x = Number(moveState.r) - Number(moveState.l);
                    direction.normalize();

                    const baseSpeed = 5.0;
                    const speed = isCrouching ? baseSpeed * 0.6 : baseSpeed;

                    if (direction.x !== 0) {
                        const moveDir = new THREE.Vector3(1, 0, 0);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.x))) {
                            controls.moveRight(direction.x * speed * delta);
                            if (checkCollision(camera.position)) controls.moveRight(-direction.x * speed * delta);
                        }
                    }

                    if (direction.z !== 0) {
                        const moveDir = new THREE.Vector3(0, 0, -1);
                        moveDir.applyQuaternion(camera.quaternion);
                        moveDir.y = 0;
                        moveDir.normalize();
                        if (!wouldFallOffEdge(camera.position, moveDir.multiplyScalar(direction.z))) {
                            controls.moveForward(direction.z * speed * delta);
                            if (checkCollision(camera.position)) controls.moveForward(-direction.z * speed * delta);
                        }
                    }

                    camera.position.y += velocity.y * delta;
                    onGround = false;

                    const currentEyeHeightForFoot = isCrouching ? CROUCH_HEIGHT : EYE_HEIGHT;
                    const footBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(camera.position.x, camera.position.y - currentEyeHeightForFoot, camera.position.z),
                        new THREE.Vector3(PLAYER_RADIUS, 0.2, PLAYER_RADIUS)
                    );

                    for (const b of blocksInScene) {
                        const bBox = new THREE.Box3().setFromObject(b);
                        if (footBox.intersectsBox(bBox)) {
                            if (velocity.y < 0) {
                                velocity.y = 0;
                                camera.position.y = bBox.max.y + currentEyeHeightForFoot;
                                onGround = true;
                            }
                        }
                    }
                }
            }

            // Breaking logic (skip for spectators)
            if (!isSpectator && isBreaking && breakingBlock) {
                const elapsed = Date.now() - breakingStartTime;
                const progress = Math.min((elapsed / breakingDuration) * 100, 100);
                document.getElementById('break-progress-bar').style.width = progress + '%';

                if (breakingOverlay && breakingTextures.length > 0) {
                    const textureIndex = Math.floor(progress / 10) - 1;
                    if (textureIndex >= 0 && textureIndex < breakingTextures.length) {
                        breakingOverlay.material.map = breakingTextures[textureIndex];
                        breakingOverlay.material.needsUpdate = true;
                    }
                }

                if (elapsed >= breakingDuration) {
                    const x = Math.floor(breakingBlock.position.x - 0.5);
                    const y = Math.floor(breakingBlock.position.y - 0.5);
                    const z = Math.floor(breakingBlock.position.z - 0.5);
                    socket.emit('breakAttempt', { x, y, z });
                    isBreaking = false;
                    breakingBlock = null;
                    document.getElementById('break-progress').style.display = 'none';
                    document.getElementById('break-progress-bar').style.width = '0%';
                    if (breakingOverlay) {
                        scene.remove(breakingOverlay);
                        breakingOverlay = null;
                    }
                }
            }

            // Player update send (for both players and spectators)
            if ((controls.isLocked || isSpectator) && socket.connected && time - lastPlayerUpdate > PLAYER_UPDATE_RATE) {
                socket.emit('playerUpdate', {
                    pos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    rot: { yaw: camera.rotation.y, pitch: camera.rotation.x },
                    crouch: isCrouching,
                    selected: selectedSlotIndex
                });
                lastPlayerUpdate = time;
            }

            // Other players lerp
            otherPlayers.forEach((data) => {
                data.group.position.lerp(new THREE.Vector3(data.targetPos.x, data.targetPos.y, data.targetPos.z), 0.15);
                data.group.rotation.y = THREE.MathUtils.lerp(data.group.rotation.y || 0, data.targetRot.yaw, 0.15);
                data.head.rotation.x = THREE.MathUtils.lerp(data.head.rotation.x || 0, data.targetRot.pitch, 0.15);
                
                // Crouch
                if (data.targetCrouch !== data.crouch) {
                    data.crouch = data.targetCrouch;
                }
                data.group.scale.y = data.crouch ? 0.75 : 1;
                
                // Spectator transparency
                if (data.targetSpectator) {
                    data.group.visible = false; // Hide spectator avatars
                } else {
                    data.group.visible = true;
                }
            });

            renderer.render(scene, camera);
        }

        // ... (rest of the original code for textures, world generation, etc. remains the same)

        // --- Updated Player Creation (with names) ---
        function getPlayerColor(id) {
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            hash = Math.abs(hash) % 360;
            const color = new THREE.Color().setHSL(hash / 360, 0.7, 0.6);
            return color;
        }

        function createOtherPlayer(id, name, isSpectator) {
            const group = new THREE.Group();
            group.name = id;
            
            if (isSpectator) {
                group.visible = false;
                return group;
            }

            // Head
            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.4;
            group.add(head);

            // Body
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyColor = getPlayerColor(id);
            const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.7;
            group.add(body);

            // Arms
            const armGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
            const armMat = bodyMat;
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(0.5, 0.7, 0);
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(-0.5, 0.7, 0);
            group.add(rightArm);

            // Legs
            const legGeo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x333366 });
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(0.2, 0, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(-0.2, 0, 0);
            group.add(rightLeg);

            // Name tag
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(name, 128, 40);
            const texture = new THREE.CanvasTexture(canvas);
            const nameMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1.2, 0.3),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true })
            );
            nameMesh.position.y = 1.8;
            group.add(nameMesh);

            scene.add(group);

            otherPlayers.set(id, {
                group,
                head,
                targetPos: { x: 0, y: 0, z: 0 },
                targetRot: { yaw: 0, pitch: 0 },
                targetCrouch: false,
                targetSpectator: isSpectator,
                crouch: false,
                spectator: isSpectator
            });
        }

        // --- Socket Events (Updated) ---
        socket.on('connect', () => {
            document.getElementById('loading').style.display = 'none';
        });

        socket.on('yourId', (id) => {
            playerId = id;
        });

        socket.on('playerName', (name) => {
            playerName = name;
            addChatMessage('System', `Welcome, ${name}!`, 'system');
        });

        socket.on('chatHistory', (messages) => {
            messages.forEach(msg => {
                addChatMessage(msg.sender, msg.message, msg.type, false);
            });
        });

        socket.on('chatMessage', (msg) => {
            const isSpectatorSender = players.get(msg.senderId)?.spectator || false;
            addChatMessage(msg.sender, msg.message, msg.type, isSpectatorSender);
        });

        socket.on('playersSnapshot', (others) => {
            others.forEach(({ id, pos, rot, crouch, name, spectator }) => {
                createOtherPlayer(id, name, spectator);
                const op = otherPlayers.get(id);
                if (op) {
                    op.targetPos = pos;
                    op.targetRot = rot;
                    op.targetCrouch = crouch;
                    op.targetSpectator = spectator;
                    op.group.visible = !spectator;
                }
            });
        });

        socket.on('newPlayer', ({ id, pos, rot, crouch, name, spectator }) => {
            createOtherPlayer(id, name, spectator);
            const op = otherPlayers.get(id);
            if (op) {
                op.targetPos = pos;
                op.targetRot = rot;
                op.targetCrouch = crouch;
                op.targetSpectator = spectator;
                op.group.visible = !spectator;
            }
        });

        socket.on('playersUpdate', (states) => {
            states.forEach(({ id, pos, rot, crouch, spectator }) => {
                if (id === playerId) return;
                const op = otherPlayers.get(id);
                if (op) {
                    op.targetPos = pos;
                    op.targetRot = rot;
                    op.targetCrouch = crouch;
                    op.targetSpectator = spectator;
                    op.group.visible = !spectator;
                }
            });
        });

        socket.on('playerSpectator', ({ id, spectator }) => {
            if (id === playerId) {
                setSpectatorMode(spectator);
            } else {
                const op = otherPlayers.get(id);
                if (op) {
                    op.targetSpectator = spectator;
                    op.group.visible = !spectator;
                }
            }
        });

        // ... (rest of the original socket events remain the same)

        // Initialize
        selectSlot(0);
        updateUI();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
